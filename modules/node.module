<?php
// $Id$

function node_help() {
  global $mod;

  if ($mod == "node") {
    foreach (module_list() as $name) {
      if (module_hook($name, "node") && $name != "node") {
        print "<h3>". t("%module type", array("%module" => ucfirst(module_invoke($name, "node", "name")))). "</h3>";
        print module_invoke($name, "help");
      }
    }
  }
}

function node_system($field){
  $system["description"] = t("The core that allows content to be submitted to the site.");
  return $system[$field];
}

// accepts a db result object which includes nid and title from node table, and name from the user table
// returns an HTML list suitable as content for a block, and eventually other uses.
function node_title_list($result, $title = NULL) {
  // no queries if site is in distress
  if (module_exist("statistics") && throttle_status() > 4) {
    return;
  }

  while ($node = db_fetch_object($result)) {
    $number = module_invoke("comment", "num_all", $node->nid);
    $name = strip_tags(format_name($node)); // required for anonymous users to work
    $items[] = l($node->title, "node/view/$node->nid", array("title" => t("Author: %name, comments: %number", array("%name" => $name, "%number" => $number))));
  }

  return theme_invoke("theme_item_list", $items, $title);
}

function node_teaser($body) {

  $size = variable_get("teaser_length", 600);

  /*
  ** If the size is zero, teasers are disabled so we
  ** return the entire body.
  */

  if ($size == 0) {
    return $body;
  }

  /*
  ** If we have a short body, return the entire body:
  */

  if (strlen($body) < $size) {
    return $body;
  }

  /*
  ** If a valid delimiter has been specified, use it to
  ** chop of the teaser.  The delimiter can be outside
  ** the allowed range but no more than a factor two.
  */

  $delimiter = strpos($body, "---");
  if ($delimiter > 0 && $delimiter < $size * 2) {
    return substr($body, 0, $delimiter);
  }

  /*
  ** In some cases no delimiter has been specified (eg.
  ** when posting using the Blogger API) in which case
  ** we try to split at paragraph boundaries.
  */

  if ($length = strpos($body, "<br />", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "<br>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "</p>", $size)) {
    return substr($body, 0, $length);
  }

  if ($length = strpos($body, "\n", $size)) {
    return substr($body, 0, $length);
  }

  /*
  ** When even the first paragraph is too long, try to
  ** split at the end of the next sentence.
  */

  if ($length = strpos($body, ". ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "! ", $size)) {
    return substr($body, 0, $length + 1);
  }

  if ($length = strpos($body, "? ", $size)) {
    return substr($body, 0, $length + 1);
  }

  /*
  ** Nevermind, we split it the hard way ...
  */

  return substr($body, 0, $size);
}

function node_invoke($node, $name, $arg = 0) {
  if (is_array($node)) {
    $function = $node["type"] ."_$name";
  }
  else if (is_object($node)) {
    $function = $node->type ."_$name";
  }
  else if (is_string($node)) {
    $function = $node ."_$name";
  }

  if (function_exists($function)) {
    return ($arg ? $function($node, $arg) : $function($node));
  }
}

function node_load($conditions) {

  /*
  ** Turn the conditions into a query:
  */

  foreach ($conditions as $key => $value) {
    $cond[] = "n.". check_query($key) ." = '". check_query($value) ."'";
  }

  /*
  ** Retrieve the node:
  */

  $node = db_fetch_object(db_query("SELECT n.*, u.uid, u.name FROM node n LEFT JOIN users u ON u.uid = n.uid WHERE ". implode(" AND ", $cond)));

  /*
  ** Unserialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = unserialize($node->revisions);
  }

  /*
  ** Call the node specific callback (if any) and piggy-back the
  ** results to the node or overwrite some values:
  */

  if ($extra = module_invoke($node->type, "load", $node)) {
    foreach ($extra as $key => $value) {
      $node->$key = $value;
    }
  }

  return $node;
}

function node_save($node, $filter) {

  $fields = array("nid", "uid", "type", "title", "teaser", "body", "revisions", "score", "status", "comment", "promote", "static", "moderate", "created", "changed", "users", "votes");

  foreach ($filter as $key => $value) {
    /*
    ** Only save those fields specified by the filter.  If the filter
    ** does not specify a default value, use the value of the $node's
    ** corresponding field instead.
    */

    if (is_numeric($key)) {
      if (isset($node->$value)) {
          // The above check is mandatory.
        $edit->$value = $node->$value;
      }
    }
    else {
      if (isset($value)) {
          // The above check is mandatory.
        $edit->$key = $value;
      }
    }
  }

  $node = $edit;

  /*
  ** Serialize the revisions field:
  */

  if ($node->revisions) {
    $node->revisions = serialize($node->revisions);
  }

  /*
  ** Apply filters to some default node fields:
  */

  if (empty($node->nid)) {

    /*
    ** Insert a new node:
    */

    // Set some required fields:
    if (!$node->created) {
      $node->created = time();
    }
    $node->changed = time();
    $node->nid = db_next_id("node");

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $k[] = check_query($key);
        $v[] = "'". check_query($value) ."'";
      }
    }

    // Insert the node into the database:
    db_query("INSERT INTO node (". implode(", ", $k) .") VALUES (". implode(", ", $v) .")");

    // Call the node specific callback (if any):
    module_invoke($node->type, "insert", $node);
  }
  else {

    /*
    ** Update an existing node:
    */

    // Set some required fields:
    $node->changed = time();

    // Prepare the query:
    foreach ($node as $key => $value) {
      if (in_array($key, $fields)) {
        $q[] = check_query($key) ." = '". check_query($value) ."'";
      }
    }

    // Update the node in the database:
    db_query("UPDATE node SET ". implode(", ", $q) ." WHERE nid = '$node->nid'");

    // Call the node specific callback (if any):
    module_invoke($node->type, "update", $node);

  }

  /*
  ** Clear the cache so an anonymous poster can see the node being added
  ** or updated.
  */

  cache_clear_all();

  /*
  ** Return the node ID:
  */

  return $node->nid;

}

function node_view($node, $main = 0) {
  global $theme;

  $node = array2object($node);

  /*
  ** Remove the delimiter (if any) that seperates the teaser from the
  ** body.
  */

  $node->body = str_replace("---", "", $node->body);

  /*
  ** The "view" hook can be implemented to overwrite the default function
  ** to display nodes.
  */

  if (module_hook($node->type, "view")) {
    node_invoke($node, "view", $main);
  }
  else {

    /*
    ** Default behavior:
    */

    $theme->node($node, $main);
  }
}

function node_show($nid, $cid) {
  global $theme, $revision;

  $node = node_load(array("status" => 1, "nid" => $nid));

  if (node_access("view", $node)) {
    if (isset($revision)) {
      $node = $node->revisions[$revision]["node"];
    }

    node_view($node);

    if (function_exists("comment_render") && $node->comment) {
      comment_render($node, $cid);
    }
  }
}

function node_access($op, $node = 0) {

  if (user_access("administer nodes")) {
    return 1;
  }

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Construct a function:
  */

  if ($node->type) {
    $type = $node->type;
  }
  else {
    $type = $node;
  }

  $function = $type ."_access";

  if (function_exists($function)) {
    return $function($op, $node);
  }
  else {
    return 0;
  }
}

function node_perm() {
  return array("administer nodes", "access content");
}

function node_search($keys) {
  global $PHP_SELF;

  // Return the results of performing a search using the indexed search
  // for this particular type of node.
  //
  // Pass an array to the "do_search" function which dictates what it
  // will search through, and what it will search for
  //
  // "keys"'s value is the keywords entered by the user
  //
  // "type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to relate the data from the specific nodes
  // table to the data that the search_index table has in it, and the the
  // do_search functino will rank it.
  //
  // The select must always provide the following fields - lno, title,
  // created, uid, name, count
  //
  $find = do_search(array("keys" => $keys, "type" => "node", "select" => "select s.lno as lno, n.title as title, n.created as created, u.uid as uid, u.name as name, s.count as count FROM search_index s, node n LEFT JOIN users u ON n.uid = u.uid WHERE s.lno = n.nid AND s.type = 'node' AND s.word like '%' AND n.status = 1"));

  return $find;
}

function node_conf_options() {
  $output .= form_select(t("Number of posts on main page"), "default_nodes_main", variable_get("default_nodes_main", 10), array(1 => 1, 2 => 2, 3 => 3, 4 => 4, 5 =>  5, 6 => 6, 7 => 7, 8 => 8, 9 => 9, 10 => 10, 15 => 15, 20 => 20, 25 => 25, 30 => 30), t("The default maximum number of posts to display on the main page."));
  $output .= form_select(t("Length of trimmed posts"), "teaser_length", variable_get("teaser_length", 600), array(0 => t("Unlimited"), 200 => t("200 characters"), 400 => t("400 characters"), 600 => t("600 characters"), 800 => t("800 characters"), 1000 => t("1000 characters"), 1200 => t("1200 characters"), 1400 => t("1400 characters"), 1600 => t("1600 characters"), 1800 => t("1800 characters"), 2000 => t("2000 characters")), t("The maximum number of characters used in the trimmed version of a post.  Drupal will use this setting to determine at which offset long posts should be trimmed.  The trimmed version of a post is typically used as a teaser when displaying the post on the main page, in XML feeds, etc.  To disable teasers, set to 'Unlimited'."));
  return $output;
}

function node_conf_filters() {
  $output .= form_select(t("Enable HTML tags"), "filter_html", variable_get("filter_html", 0), array(t("Disabled"), t("Enabled")), t("Allow HTML and PHP tags in user-contributed content."));
  $output .= form_textfield(t("Allowed HTML tags"), "allowed_html", variable_get("allowed_html", "<a> <b> <dd> <dl> <dt> <i> <li> <ol> <u> <ul>"), 64, 255, t("If enabled, optionally specify tags which should not be stripped.  'STYLE' attributes, 'ON' attributes and unclosed tags are always stripped."));
  $output .= "<hr />";
  $output .= form_select(t("Enable link tags"), "filter_link", variable_get("filter_link", 0), array(t("Disabled"), t("Enabled")), t("Substitute special [[nodesubject|text]] tags. Your browser will display 'text', and when you click on it your browser will open the node with the subject 'nodesubject'. Please be aware that you'll need to copy the subject of the target node exactly in order to use this feature."));
  $output .= "<hr />";
  return $output;
}

function node_filter_html($text) {
  $text = strip_tags($text, variable_get("allowed_html", ""));
  return $text;
}

function node_filter_link($text) {
  $pat = '\[{2}([^\|]+)(\|([^\|]+)?)?\]{2}';                   // [link|description]
//  $dst = str_replace('%5C1', '\\1', format_tag('\\1', '\\3')); // [link|description]
  return ereg_replace($pat, $dst, $text);
}

function node_comment_mode($nid) {
  static $comment_mode;
  if (!isset($comment_mode[$nid])) {
    $comment_mode[$nid] = db_result(db_query("SELECT comment FROM node WHERE nid = '%s'", $nid));
  }
  return $comment_mode[$nid];
}

function node_filter($text) {
  $text = preg_replace("/\Wstyle\s*=[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Won[a-z]+\s*=[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Wsrc\s*=[\s'\"]*javascript[^>]+?>/i", ">", $text);
  $text = preg_replace("/\Whref\s*=[\s'\"]*javascript:[^>]+?>/i", ">", $text);

  if (variable_get("filter_html", 0)) $text = node_filter_html($text);
  // if (variable_get("filter_link", 0)) $text = node_filter_link($text);

  return trim($text);
}

function node_link($type, $node = 0, $main = 0) {

  if ($type == "page") {
    $links[] = l(t("submit"), "node/add", array("title" => t("Submit or suggest new content.")));
  }

  if ($type == "node") {
    if ($node->links) {
      $links = $node->links;
    }

    if ($main == 1 && $node->teaser && $node->teaser != $node->body) {
      $links[] = l(t("read more"), "node/view/$node->nid", array("title" => t("Read the rest of this posting.")));
    }

    if (user_access("administer nodes")) {
       $links[] = l(t("administer"), "node/edit/$node->nid", array("title" => t("Administer this node.")));
    }
  }

  if ($type == "admin" && user_access("administer nodes")) {
    $search = "On this page you can search for a post.  For example, one may search for 'br' and Drupal might return 'bread brakers', 'our daily bread' and 'brenda'.";

    menu_add("content management", url("admin/node"), "Content management.", NULL, NULL);
     menu_add("submit new content", url("node/add"), "Submit new content.", NULL, "content management", -1);
     menu_add("new or updated posts", url("admin/node/nodes/0"), "Display all new or updated posts.", NULL, "content management", 0);
     menu_add("posts that await approval", url("admin/node/nodes/1"), "Display posts that await approval.", NULL, "content management", 0);
     menu_add("search content", url("admin/node/search"), "Search a post.", $search, "content management", 5);
     menu_add("help", url("admin/node/help"), "More information about content management.", NULL, "content management", 7);
  }

  return $links ? $links : array();
}

function node_admin_edit($node) {

  if (is_numeric($node)) {
    $node = node_load(array("nid" => $node));
  }

  /*
  ** Edit node:
  */

  $output .= "<h3>". t("Edit %module", array("%module" => module_invoke($node->type, "node", "name"))) ."</h3>";

  $output .= node_form($node);

  /*
  ** Edit revisions:
  */

  if ($node->revisions) {
    $output .= "<h3>". t("Edit revisions") ."</h3>";
    $output .= "<table border=\"1\" cellpadding=\"2\" cellspacing=\"2\">";
    $output .= " <tr><th>". t("older revisions") ."</th><th colspan=\"3\">". t("operations") ."</th></tr>";
    foreach ($node->revisions as $key => $revision) {
      $output .= " <tr><td>". t("revision #%r revised by %u on %d", array("%r" => $key, "%u" => format_name(user_load(array("uid" => $revision["uid"]))), "%d" => format_date($revision["timestamp"], "small"))) . ($revision["history"] ? "<br /><small>". $revision["history"] ."</small>" : "") ."</td><td>". l(t("view revision"), "node/view/$node->nid", array(), "revision=$key") ."</td><td>". l(t("rollback revision"), "admin/node/rollback+revision/$node->nid/$key") ."</td><td>". l(t("delete revision"), "admin/node/delete+revision/$node->nid/$key") ."</td></tr>";
    }
    $output .= "</table>";
  }

  /*
  ** Display the node form extensions:
  */

  foreach (module_list() as $name) {
    $output .= module_invoke($name, "node_link", $node);
  }

  return $output;

}

function node_admin_nodes() {

  $query = arg(3);
  $queries = array("ORDER BY n.changed DESC", "WHERE n.status = 0 OR n.moderate = 1 ORDER BY n.changed DESC");

  $result = pager_query("SELECT n.*, u.name, u.uid FROM node n LEFT JOIN users u ON n.uid = u.uid ". $queries[$query ? $query : 0], 50);

  $header = array(t("title"), t("type"), t("author"), t("status"), array("data" => t("operations"), "colspan" => 2));

  while ($node = db_fetch_object($result)) {
    $rows[] = array(l($node->title, "node/view/$node->nid"), module_invoke($node->type, "node", "name"), format_name($node), ($node->status ? t("published") : t("not published")), l(t("edit node"), "admin/node/edit/$node->nid"), l(t("delete node"), "admin/node/delete/$node->nid"));
  }

  if ($pager = pager_display(NULL, 50, 0, "admin")) {
    $rows[] = array(array("data" => $pager, "colspan" => 6));
  }

  return table($header, $rows);
}

/*
** Return the revision with the specified revision number.
*/

function node_revision_load($node, $revision) {
  return $node->revisions[$revision]["node"];
}

/*
** Create and return a new revision of the given node.
*/

function node_revision_create($node) {
  global $user;

  /*
  ** 'revision' is the name of the field used to indicicate that we
  ** have to create a new revision of a node.
  */

  if ($node->nid && $node->revision) {
    $prev = node_load(array("nid" => $node->nid));
    $node->revisions = $prev->revisions;
    unset($prev->revisions);
    $node->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $prev, "history" => $node->history);
  }

  return $node;
}

/*
** Roll-back to the revision with the specified revision number.
*/

function node_revision_rollback($node, $revision) {
  global $user;

  /*
  ** Extract the specified revision:
  */

  $rev = $node->revisions[$revision]["node"];

  /*
  ** Inherit all the past revisions:
  */

  $rev->revisions = $node->revisions;

  /*
  ** Save the original/current node:
  */

  $rev->revisions[] = array("uid" => $user->uid, "timestamp" => time(), "node" => $node);

  /*
  ** Remove the specified revision:
  */

  unset($rev->revisions[$revision]);

  /*
  ** Save the node:
  */

  foreach ($node as $key => $value) {
    $filter[] = $key;
  }

  node_save($rev, $filter);

  watchdog("special", "$node->type: rollbacked to revision #$revision of '$node->title'");
}

/*
** Delete the revision with specified revision number.
*/

function node_revision_delete($node, $revision) {

  unset($node->revisions[$revision]);

  node_save($node, array("nid", "revisions"));

  watchdog("special", "$node->type: removed revision #$revision of '$node->title'");
}

/*
** Return a list of all the existing revision numbers.
*/

function node_revision_list($node) {
  if (is_array($node->revisions)) {
    return array_keys($node->revisions);
  }
  else {
    return array();
  }
}

function node_admin() {
  global $op, $edit;

  if (user_access("administer nodes")) {

    if (empty($op)) {
      $op = arg(2);
    }

    /*
    ** Compile a list of the administrative links:
    */

    switch ($op) {
      case "help":
        print node_help();
        break;
      case "search":
        print search_type("node", url("admin/node/search"));
        break;
      case "edit":
        print node_admin_edit(arg(3));
        break;
      case "delete":
        print node_delete(array("nid" => arg(3)));
        break;
      case "rollback+revision":
        print node_revision_rollback(node_load(array("nid" => arg(3))), arg(5));
        print node_admin_edit(arg(4));
        break;
      case "delete+revision":
        print node_revision_delete(node_load(array("nid" => arg(3))), arg(5));
        print node_admin_edit(arg(4));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        print node_preview($edit);
        break;
      case t("Submit"):
        print node_submit($edit);
        break;
      case t("Delete"):
        print node_delete($edit);
        break;
      default:
        print node_admin_nodes();
    }
  }
  else {
    print message_access();
  }
}

function node_block($op = "list", $delta = 0) {
  global $theme;
  if ($op == "list") {
    $blocks[0]["info"] = t("Syndicate");
    return $blocks;
  }
  else {
    $block["subject"] = t("Syndicate");
    $block["content"] = "<div align=\"center\">". l("<img src=\"". $theme->image("xml.gif") ."\" width=\"36\" height=\"14\" border=\"0\" alt=\"XML\" />", "node/feed", array("title" => t("Read the XML version of this page."))) ."</div>";

    return $block;
  }
}

function node_feed($nodes = 0, $channel = array()) {
  /*
  ** A generic function for generating RSS feeds from a set of nodes.
  **   - $nodes should be an object as returned by db_query() which contains
  **     the nid field.
  **   - $channel is an associative array containing title, link, and
  **     description keys.
  */

  if (!$nodes) {
    $nodes = db_query("SELECT nid FROM node WHERE promote = '1' AND status = '1' ORDER BY created DESC LIMIT 15");
  }

  while ($node = db_fetch_object($nodes)) {
    $item = node_load(array("nid" => $node->nid));
    $link = path_uri() . url("node/view/$item->nid");
    $items .= format_rss_item($item->title, $link, $item->teaser);
  }

  $output .= "<?xml version=\"1.0\" ". t("encoding=\"ISO-8859-1\""). "?>\n";
  $output .= "<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC \"-//W3C//ENTITIES Latin 1 for XHTML//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent\">]>\n";
    // NOTE: &eacute; - for example - is the correct ISO-8859-1 translation of é (e acute) but apparently XML parsers don't (have to) understand it.  To solve this problem, we use a DTD that defines commonly used entity such as &eacute;.
  if (!$channel["version"]) $channel["version"] = "0.91";
  if (!$channel["title"]) $channel["title"] = variable_get("site_name", "drupal") ." - ". variable_get("site_slogan", "");
  if (!$channel["link"]) $channel["link"] = path_uri();
  if (!$channel["description"]) $channel["description"] = variable_get("site_mission", "");
  if (!$channel["language"]) $channel["language"] = "en";
  $output .= "<rss version=\"". $channel["version"] . "\">\n";
  $output .= format_rss_channel($channel["title"], $channel["link"], $channel["description"], $items, $channel["language"]);
  $output .= "</rss>\n";

  header("Content-Type: text/xml");
  print $output;
}

function node_validate($node, &$error) {

  global $user;

  /*
  ** Convert the node to an object if necessary:
  */

  $node = array2object($node);

  /*
  ** Validate the title field:
  */

  if (isset($node->title) && !$node->title) {
    $error["title"] = theme_invoke("theme_error", t("You have to specify a valid title."));
  }

  if (user_access("administer nodes")) {

    /*
    ** Setup default values if required:
    */

    if (!$node->created) {
      $node->created = time();
    }

    if (!$node->date) {
      $node->date = date("M j, Y g:i a", $node->created);
    }

    /*
    ** Validate the "authored by"-field:
    */

    if (empty($node->name)) {
      /*
      ** The use of empty() is mandatory in the context of usernames
      ** as the empty string denotes the anonymous user.  In case we
      ** are dealing with an anomymous user we set the user ID to 0.
      */
      $node->uid = 0;
    }
    else if ($account = user_load(array("name" => $node->name))) {
      $node->uid = $account->uid;
    }
    else {
      $error["name"] = theme_invoke("theme_error", t("The name '%u' does not exist.", array ("%u" => $node->name)));
    }

    /*
    ** Validate the "authored on"-field:
    */

    if (strtotime($node->date) > 1000) {
      $node->created = strtotime($node->date);
    }
    else {
      $error["date"] = theme_invoke("theme_error", t("You have to specifiy a valid date."));
    }
  }

  /*
  ** Do node type specific validation checks.
  */

  $function = $node->type ."_validate";
  if (function_exists($function)) {
    $node = $function($node, $error);
  }

  return $node;
}


function node_form($edit, $error = NULL) {

  /*
  ** Save the referer.  We record where the user came from such that we
  ** can redirect him after having completed the node forms.
  */

  referer_save();

  /*
  ** Validate the node:
  */

  if (!$error) {
    /* Only validate if we don't already know the errors. */
    $edit = node_validate($edit, $error);
  }

  /*
  ** Get the node specific bits:
  */

  $function = $edit->type ."_form";
  if (function_exists($function)) {
    $form .= $function($edit, $help, $error, $param);
  }

  /*
  ** Add the help text:
  */

  if ($help) {
    $output .= "<p>$help</p>";
  }

  $output .= "<table border=\"0\" cellpadding=\"2\" cellspacing=\"2\">";
  $output .= " <tr>";
  $output .= "  <td valign=\"top\">";

  /*
  ** Add the default fields:
  */

  $output .= form_textfield(t("Title"), "title", $edit->title, 60, 64, $error["title"]);

  /*
  ** Add the node specific fields:
  */

  $output .= $form;

  /*
  ** Add the hidden fields:
  */

  if ($edit->nid) {
    $output .= form_hidden("nid", $edit->nid);
  }

  if (isset($edit->uid)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */
    $output .= form_hidden("uid", $edit->uid);
  }

  if ($edit->created) {
    $output .= form_hidden("created", $edit->created);
  }

  $output .= form_hidden("type", $edit->type);

  /*
  ** Add the buttons:
  */

  $output .= form_submit(t("Preview"));

  if ($edit->title && $edit->type && !$error) {
    $output .= form_submit(t("Submit"));
  }

  if ($edit->nid && node_access("delete", $edit)) {
    $output .= form_submit(t("Delete"));
  }

  /*
  ** Add the admin specific parts:
  */

  if (user_access("administer nodes")) {
    $output .= "</td><td align=\"left\" valign=\"top\">";
    $output .= form_textfield(t("Authored by"), "name", $edit->name, 20, 60, $error["name"]);
    $output .= form_textfield(t("Authored on"), "date", $edit->date, 20, 25, $error["date"]);
    $output .= "<br />";
    $output .= form_select(t("Set public/published"), "status", $edit->status, array(t("Disabled"), t("Enabled")));
    $output .= form_select(t("Moderation status"), "moderate", $edit->moderate, array(t("Approved"), t("Awaiting approval")));
    $output .= form_select(t("Promote to front page"), "promote", $edit->promote, array(t("Disabled"), t("Enabled")));
    $output .= form_select(t("Static on front page"), "static", $edit->static, array(t("Disabled"), t("Enabled")));
    // TODO: move this to the comment.module
    if (module_exist("comment")) {
      $output .= form_select(t("Allow user comments"), "comment", $edit->comment, array(t("Disabled"), t("Read only"), t("Read-write")));
    }
    $output .= form_select(t("Create new revision"), "revision", $edit->revision, array(t("Disabled"), t("Enabled")));
  }

  $output .= "  </td>";
  $output .= " </tr>";
  $output .= "</table>";

  return form($output, ($param["method"] ? $param["method"] : "post"), $param["action"], $param["options"]);
}

function node_add($type) {
  global $user, $edit;

  /*
  ** If a node type has been specified, validate it existence.  If no
  ** (valid) node type has been provied, display a node type overview.
  */

  if ($type && node_access("create", $type)) {
    // Initialize settings
    $node = array("uid" => $user->uid, "name" => $user->name, "type" => $type, "status" => 1, "promote" => !module_exist("queue"), "moderate" => module_exist("queue"), "comment" => 2);
    foreach (array("title", "teaser", "body") as $field) {
      if ($edit[$field]) {
        $node[$field] = check_input($edit[$field]);
      }
    }
    $output = node_form($node);
  }
  else {

    /*
    ** Compile a list with the different node types and their explanation:
    */

    foreach (module_list() as $name) {
      if (module_hook($name, "node") && node_access("create", $name)) {
        $output .= "<li>";
        $output .= " ". l(module_invoke($name, "node", "name"), "node/add/$name", array("title" => t("Add a new %s.", array("%s" => module_invoke($name, "node", "name")))));
        $output .= " <div style=\"margin-left: 20px;\">". module_invoke($name, "node", "description") ."</div>";
        $output .= "</li>";
      }
    }

    $output = t("Choose the appropriate item from the list:") ."<ul>$output</ul>";

  }

  return $output;
}

function node_edit($id) {
  global $user;

  $node = node_load(array("nid" => $id));

  if (node_access("update", $node)) {
    $output = node_form($node);
  }
  else {
    $output = message_access();
  }

  return $output;
}

function node_preview($node, $error = NULL) {

  /*
  ** Convert the array to an object:
  */

  $node = array2object($node);

  if (node_access("create", $node) || node_access("update", $node)) {

    /*
    ** Load the user's name when needed:
    */

    if (isset($node->name)) {
      /*
      ** The use of isset() is mandatory in the context of user IDs as uid
      ** 0 denotes the anonymous user.
      */

      if ($user = user_load(array("name" => $node->name))) {
        $node->uid = $user->uid;
      }
      else {
        $node->uid = 0; // anonymous user
      }
    }
    else if ($node->uid) {
      $user = user_load(array("uid" => $node->uid));
      $node->name = $user->name;
    }

    /*
    ** Set the created time when needed:
    */

    if (empty($node->created)) {
      $node->created = time();
    }

    /*
    ** Exctract a teaser:
    */

    $node->teaser = node_teaser($node->body);

    /*
    ** Apply the required filters:
    */

    if ($node->nid) {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "update", $node)));
    }
    else {
      $view = array2object(array_merge(object2array($node), module_invoke($node->type, "save", "create", $node)));
    }

    /*
    ** Display a prenode of the node:
    */

    if ($view->teaser && $view->teaser != $view->body) {
      print "<h3>". t("Preview trimmed version") ."</h3>";
      node_view($view, 1);
      print "<p><i>". t("The trimmed version of your post shows how your post looks like when promoted to the main page or when exported for syndication.  You can insert a delimiter '---' (without the quotes) to fine-tune where your post gets split.  However note that delimiter will be ignored when misplaced.") ."</i></p>";
      print "<h3>". t("Preview full version") ."</h3>";
      node_view($view, 0);
    }
    else {
      node_view($view, 0);
    }

    return node_form($node, $error);
  }
}

function node_submit($node) {
  global $user, $theme;

  /*
  ** Fixup the node when required:
  */

  $node = node_validate($node, $error);

  /*
  ** If something went wrong, go back to the preview form:
  */

  if ($error) {
    return node_preview($node, $error);
  }

  /*
  ** Create a new revision when required:
  */

  $node = node_revision_create($node);

  /*
  ** Prepare the node's body:
  */

  if ($node->nid) {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("update", $node)) {

      /*
      ** Compile a list of the node fields and their default values that users
      ** and administrators are allowed to save when updating a node.
      */

      if (user_access("administer nodes")) {
        $fields = array("nid", "uid", "body", "comment", "created", "promote", "static", "moderate", "revisions", "status", "teaser" => node_teaser($node->body), "title", "type" => $node->type);
      }
      else {
        $fields = array("nid", "uid" => ($user->uid ? $user->uid : 0), "body", "teaser" => node_teaser($node->body), "title", "type" => $node->type);
      }

      $nid = node_save($node, array_merge($fields, module_invoke($node->type, "save", "update", $node)));

      /*
      ** Update terms of the node
      */

      if (function_exists("taxonomy_node_save")) {
        taxonomy_node_save($nid, $node->taxonomy);
      }

      watchdog("special", "$node->type: updated '$node->title'", l("view post", "node/view/$node->nid"));
      $output = t("The node has been updated.");
    }
  }
  else {

    /*
    ** Check whether the current user has the proper access rights to
    ** perform this operation:
    */

    if (node_access("create", $node)) {

      /*
      ** Verify a user's submission rate and avoid duplicate nodes being
      ** inserted:
      */

      throttle("node", variable_get("max_node_rate", 900));

      /*
      ** Compile a list of the node fields and their default values that users
      ** and administrators are allowed to save when inserting a new node.
      */

      if (user_access("administer nodes")) {
        $fields = array("uid", "body", "comment", "created", "promote", "static", "moderate", "status", "teaser" => node_teaser($node->body), "title", "type" => $node->type);
      }
      else {
        $fields = array("uid" => ($user->uid ? $user->uid : 0), "body", "comment" => 2, "teaser" => node_teaser($node->body), "title", "type" => $node->type);
      }

      $nid = node_save($node, array_merge($fields, module_invoke($node->type, "save", "create", $node)));

      /*
      ** Insert terms of the node
      */

      if (function_exists("taxonomy_node_save")) {
        taxonomy_node_save($nid, $node->taxonomy);
      }

      watchdog("special", "$node->type: added '$node->title'", l("view post", "node/view/$nid"));
      $output = t("Thanks for your submission.");
    }
  }

  /*
  ** Reload the node from the database:
  */

  $node = node_load(array("nid" => $nid));

  /*
  ** For usability's sake, make sure to present the user with some
  ** useful links as where to go next.
  */

  if ($referer = referer_load()) {
    $links[] = "<a href=\"$referer\">". t("return") ."</a>";
  }

  if ($nid && node_access("view", $node)) {
    $links[] = l(t("view"), "node/view/$nid");
  }

  if ($nid && node_access("update", $node)) {
    $links[] = l(t("edit"), "node/edit/$nid");
  }

  $output .= "<p>". $theme->links($links) ."</p>";

  return $output;
}

function node_delete($edit) {

  $node = node_load(array("nid" => $edit["nid"]));

  if (node_access("delete", $node)) {

    if ($edit["confirm"]) {

      /*
      ** Delete the specified node and its comments:
      */

      db_query("DELETE FROM node WHERE nid = '$node->nid'");
      db_query("DELETE FROM comments WHERE nid = '$node->nid'");

      /*
      ** Delete any taxonomy terms
      */

      module_invoke("taxonomy", "node_delete", $node->nid);

      /*
      ** Delete related node statistics
      */

      module_invoke("statistics", "node_delete", $node->nid);

      /*
      ** Call the node specific callback (if any):
      */

      module_invoke($node->type, "delete", $node);

      watchdog("special", "$node->type: deleted '$node->title'");
      $output = t("The node has been deleted.");
    }
    else {
      $output .= form_item(t("Confirm deletion"), $node->title);
      $output .= form_hidden("nid", $node->nid);
      $output .= form_hidden("confirm", 1);
      $output .= form_submit(t("Delete"));
      $output = form($output);
    }
  }

  return $output;
}

function node_page() {
  global $op, $id, $user, $edit, $theme, $or, $and;

  if (user_access("access content")) {
    if (empty($op)) {
      $op = arg(1);
    }

    if ($op == "feed") {
      node_feed();
      return;
    }

    $theme->header();

    switch ($op) {
      case "add":
        $theme->box(t("Create new post"), node_add(arg(2)));
        break;
      case "edit":
        $theme->box(t("Edit post"), node_edit(arg(2)));
        break;
      case "view":
        print node_show(arg(2), arg(3));
        break;
      case t("Preview"):
        $edit = node_validate($edit, $error);
        $theme->box(t("Preview post"), node_preview($edit, $error));
        break;
      case t("Submit"):
        $theme->box(t("Submit post"), node_submit($edit));
        break;
      case t("Delete"):
        $theme->box(t("Delete post"), node_delete($edit));
        break;
      default:
        // prepare query
        if ($or) {
          foreach ((explode(",", $or)) as $t) {
            $terms[] = "'".check_query($t)."'";
          }
        }
        else if ($and) {
          foreach ((explode(",", $and)) as $t) {
            $terms[] = "'".check_query($t)."'";
          }
        }

        if ($or) {
          // this is an OR of terms
          $result = pager_query("SELECT DISTINCT(n.nid), type FROM node n LEFT JOIN term_node r ON n.nid = r.nid WHERE tid IN (".implode(",", $terms).") AND ". ($id ? "nid = '$id' AND " : "") ."status = '1' ORDER BY static DESC, created DESC", ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }
        else if ($and) {
          // this is an AND
          $result = pager_query("SELECT n.nid, n.type FROM node n LEFT JOIN term_node r ON n.nid = r.nid WHERE tid IN (".implode(",", $terms).") AND ". ($id ? "nid = '$id' AND " : "") ."status = '1' GROUP BY n.nid, n.type, n.status, n.static, n.created HAVING COUNT(n.nid) = ".count($terms)." ORDER BY static DESC, created DESC", ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }
        else {
          $result = pager_query("SELECT nid, type FROM node WHERE ". ($id ? "nid = '$id'" : "promote = '1'") ." AND status = '1' ORDER BY static DESC, created DESC", ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
        }

        while ($node = db_fetch_object($result)) {
          node_view(node_load(array("nid" => $node->nid, "type" => $node->type)), 1);
        }

        print pager_display(NULL, ($user->nodes ? $user->nodes : variable_get("default_nodes_main", 10)));
    }
  }
  else {
    $theme->box(t("Access denied"), message_access());
  }

  $theme->footer();
}

function node_update_index() {

  // Return an array of values to dictate how to update the search index
  // for this particular type of node.
  //
  // "last_update"'s value is used with variable_set to set the
  // last time this node type had an index update run.
  //
  // "node_type"'s value is used to identify the node type in the search
  // index.
  //
  // "select"'s value is used to select the node id and text fields from
  // the table we are indexing. In this case, we also check against the
  // last run date for the nodes update.
  return array("last_update" => "node_cron_last",
         "node_type" => "node",
         "select" => "SELECT n.nid as lno, n.title as text1, n.body as text2 FROM node n WHERE n.status = 1 AND moderate = 0 and (created > " . variable_get("node_cron_last", 1) . " or changed > " . variable_get("node_cron_last", 1) . ")");
}

?>
