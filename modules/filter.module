<?php

/**
 * @file
 * Framework for handling filtering of content.
 */

// This is a special format ID which means "use the default format". This value
// can be passed to the filter APIs as a format ID: this is equivalent to not
// passing an explicit format at all.
define('FILTER_FORMAT_DEFAULT', 0);

define('FILTER_HTML_STRIP', 1);
define('FILTER_HTML_ESCAPE', 2);

/**
 * Implementation of hook_help().
 */
function filter_help($section) {
  switch ($section) {
    case 'admin/modules#description':
      return t('Handles the filtering of content in preparation for display.');

    case 'admin/filters':
      return t('
<p><em>Input formats</em> define a way of processing user-supplied text in Drupal. Every input format has its own settings of which <em>filters</em> to apply. Possible filters include stripping out malicious HTML and making URLs clickable.</p>
<p>Users can choose between the available input formats when submitting content.</p>
<p>Below you can configure which input formats are available to which roles, as well as choose a default input format (used for imported content, for example).</p>');

    case 'admin/filters/'. arg(2):
      return t('
<p>Every <em>filter</em> performs one particular change on the user input, for example stripping out malicious HTML or making URLs clickable. Choose which filters you want to apply to text in this input format.</p>
<p>If you notice some filters are causing conflicts in the output, you can <a href="%order">rearrange them</a>.</p>', array('%order' => check_url(url('admin/filters/'. arg(2) .'/order'))));

    case 'admin/filters/'. arg(2) .'/configure':
      return t('
<p>If you cannot find the settings for a certain filter, make sure you\'ve enabled it on the <a href="%url">list filters</a> tab first.</p>', array('%url' => check_url(url('admin/filters/'. arg(2) .'/list'))));

    case 'admin/filters/'. arg(2) .'/order':
      return t('
<p>Because of the flexible filtering system, you might encounter a situation where one filter prevents another from doing its job. For example: a word in an URL gets converted into a glossary term, before the URL can be converted in a clickable link. When this happens, you will need to rearrange the order in which filters get executed.</p>
<p>Filters are executed from top-to-bottom. You can use the weight column to rearrange them: heavier filters \'sink\' to the bottom.</p>');
  }
}

/**
 * Implementation of hook_filter_tips().
 */
function filter_filter_tips($delta, $format, $long = false) {
  global $base_url;
  switch ($delta) {
    case 0:
      if (variable_get("filter_html_$format", FILTER_HTML_STRIP) ==  FILTER_HTML_STRIP) {
        if ($allowed_html = variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>')) {
          switch ($long) {
            case 0:
              return t('Allowed HTML tags') .': '. check_plain($allowed_html);
            case 1:
              $output = '<p>'. t('Allowed HTML tags') .': '. check_plain($allowed_html) .'</p>';
              if (!variable_get("filter_html_help_$format", 1)) {
                return $output;
              }

              $output .= t('<p>This site allows HTML content. While learning all of HTML may feel intimidating, learning how to use a very small number of the most basic HTML "tags" is very easy. This table provides examples for each tag that is enabled on this site.</p>
<p>For more information see W3C\'s <a href="http://www.w3.org/TR/html/">HTML Specifications</a> or use your favorite search engine to find other sites that explain HTML.</p>');
              $tips = array(
                'a' => array( t('Anchors are used to make links to other pages.'), '<a href="'. $base_url .'">'. variable_get('site_name', 'drupal') .'</a>'),
                'br' => array( t('By default line break tags are automatically added, so use this tag to add additional ones. Use of this tag is different because it is not used with an open/close pair like all the others. Use the extra " /" inside the tag to maintain XHTML 1.0 compatibility'), t('Text with <br />line break')),
                'p' => array( t('By default paragraph tags are automatically added, so use this tag to add additional ones.'), '<p>'. t('Paragraph one.') .'</p> <p>'. t('Paragraph two.') .'</p>'),
                'strong' => array( t('Strong'), '<strong>'. t('Strong'). '</strong>'),
                'em' => array( t('Emphasized'), '<em>'. t('Emphasized') .'</em>'),
                'cite' => array( t('Cited'), '<cite>'. t('Cited') .'</cite>'),
                'code' => array( t('Coded text used to show programming source code'), '<code>'. t('Coded') .'</code>'),
                'b' => array( t('Bolded'), '<b>'. t('Bolded') .'</b>'),
                'u' => array( t('Underlined'), '<u>'. t('Underlined') .'</u>'),
                'i' => array( t('Italicized'), '<i>'. t('Italicized') .'</i>'),
                'sup' => array( t('Superscripted'), t('<sup>Super</sup>scripted')),
                'sub' => array( t('Subscripted'), t('<sub>Sub</sub>scripted')),
                'pre' => array( t('Preformatted'), '<pre>'. t('Preformatted') .'</pre>'),
                'blockquote' => array( t('Block quoted'), '<blockquote>'. t('Block quoted') .'</blockquote>'),
                'q' => array( t('Quoted inline'), '<q>'. t('Quoted inline') .'</q>'),
                // Assumes and describes tr, td, th.
                'table' => array( t('Table'), '<table> <tr><th>'. t('Table header') .'</th></tr> <tr><td>'. t('Table cell') .'</td></tr> </table>'),
                'tr' => NULL, 'td' => NULL, 'th' => NULL,
                'del' => array( t('Deleted'), '<del>'. t('Deleted') .'</del>'),
                'ins' => array( t('Inserted'), '<ins>'. t('Inserted') .'</ins>'),
                // Assumes and describes li.
                'ol' => array( t('Ordered list - use the &lt;li&gt; to begin each list item'), '<ol> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ol>'),
                'ul' => array( t('Unordered list - use the &lt;li&gt; to begin each list item'), '<ul> <li>'. t('First item') .'</li> <li>'. t('Second item') .'</li> </ul>'),
                'li' => NULL,
                // Assumes and describes dt and dd.
                'dl' => array( t('Definition lists are similar to other HTML lists. &lt;dl&gt; begins the definition list, &lt;dt&gt; begins the definition term and &lt;dd&gt; begins the definition description.'), '<dl> <dt>'. t('First term') .'</dt> <dd>'. t('First definition') .'</dd> <dt>'. t('Second term') .'</dt> <dd>'. t('Second definition') .'</dd> </dl>'),
                'dt' => NULL, 'dd' => NULL,
                'h1' => array( t('Header'), '<h1>'. t('Title') .'</h1>'),
                'h2' => array( t('Header'), '<h2>'. t('Subtitle') .'</h2>'),
                'h3' => array( t('Header'), '<h3>'. t('Subtitle three') .'</h3>'),
                'h4' => array( t('Header'), '<h4>'. t('Subtitle four') .'</h4>'),
                'h5' => array( t('Header'), '<h5>'. t('Subtitle five') .'</h5>'),
                'h6' => array( t('Header'), '<h6>'. t('Subtitle six') .'</h6>')
              );
              $header = array(t('Tag Description'), t('You Type'), t('You Get'));
              preg_match_all('/<([a-z0-9]+)[^a-z0-9]/i', $allowed_html, $out);
              foreach ($out[1] as $tag) {
                if (array_key_exists($tag, $tips)) {
                  if ($tips[$tag]) {
                    $rows[] = array(
                      array('data' => $tips[$tag][0], 'class' => 'description'),
                      array('data' => '<code>'. check_plain($tips[$tag][1]) .'</code>', 'class' => 'type'),
                      array('data' => $tips[$tag][1], 'class' => 'get')
                    );
                  }
                }
                else {
                  $rows[] = array(
                    array('data' => t('No help provided for tag %tag.', array('%tag' => check_plain($tag))), 'class' => 'description', 'colspan' => 3),
                  );
                }
              }
              $output .= theme('table', $header, $rows);

              $output .= t('<p>Most unusual characters can be directly entered without any problems.</p>
<p>If you do encounter problems, try using HTML character entities. A common example looks like &amp;amp; for an ampersand &amp; character. For a full list of entities see HTML\'s <a href="http://www.w3.org/TR/html4/sgml/entities.html">entities</a> page. Some of the available characters include:</p>');
              $entities = array(
                array( t('Ampersand'), '&amp;'),
                array( t('Greater than'), '&gt;'),
                array( t('Less than'), '&lt;'),
                array( t('Quotation mark'), '&quot;'),
              );
              $header = array(t('Character Description'), t('You Type'), t('You Get'));
              unset($rows);
              foreach ($entities as $entity) {
                $rows[] = array(
                  array('data' => $entity[0], 'class' => 'description'),
                  array('data' => '<code>'. check_plain($entity[1]) .'</code>', 'class' => 'type'),
                  array('data' => $entity[1], 'class' => 'get')
                );
              }
              $output .= theme('table', $header, $rows);
              return $output;
            }
          }
        }
        else {
          return t('No HTML tags allowed');
        }
      break;

    case 1:
      switch ($long) {
        case 0:
          return t('You may post PHP code. You should include &lt;?php ?&gt; tags.');
        case 1:
          return t('
<h4>Using custom PHP code</h4>
<p>If you know how to script in PHP, Drupal gives you the power to embed any script you like. It will be executed when the page is viewed and dynamically embedded into the page. This gives you amazing flexibility and power, but of course with that comes danger and insecurity if you don\'t write good code. If you are not familiar with PHP, SQL or with the site engine, avoid experimenting with PHP because you can corrupt your database or render your site insecure or even unusable! If you don\'t plan to do fancy stuff with your content then you\'re probably better off with straight HTML.</p>
<p>Remember that the code within each PHP item must be valid PHP code - including things like correctly terminating statements with a semicolon. It is highly recommended that you develop your code separately using a simple test script on top of a test database before migrating to your production environment.</p>
<p>Notes:</p><ul><li>You can use global variables, such as configuration parameters, within the scope of your PHP code but remember that global variables which have been given values in your code will retain these values in the engine afterwards.</li><li>register_globals is now set to <strong>off</strong> by default. If you need form information you need to get it from the "superglobals" $_POST, $_GET, etc.</li><li>You can either use the <code>print</code> or <code>return</code> statement to output the actual content for your item.</li></ul>
<p>A basic example:</p>
<blockquote><p>You want to have a box with the title "Welcome" that you use to greet your visitors. The content for this box could be created by going:</p>
<pre>
  print t("Welcome visitor, ... welcome message goes here ...");
</pre>
<p>If we are however dealing with a registered user, we can customize the message by using:</p>
<pre>
  global $user;
  if ($user->uid) {
    print t("Welcome $user->name, ... welcome message goes here ...");
  }
  else {
    print t("Welcome visitor, ... welcome message goes here ...");
  }
</pre></blockquote>
<p>For more in-depth examples, we recommend that you check the existing Drupal code and use it as a starting point, especially for sidebar boxes.</p>');
      }

    case 2:
      switch ($long) {
        case 0:
          return t('Lines and paragraphs break automatically.');
        case 1:
          return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');
      break;
      }
  }
}


/**
 * Implementation of hook_menu().
 */
function filter_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'admin/filters', 'title' => t('input formats'),
      'callback' => 'filter_admin_overview',
      'access' => user_access('administer filters'));

    $items[] = array('path' => 'admin/filters/delete', 'title' => t('delete input format'),
      'callback' => 'filter_admin_delete',
      'type' => MENU_CALLBACK,
      'access' => user_access('administer filters'));

    $items[] = array('path' => 'filter/tips', 'title' => t('compose tips'),
      'callback' => 'filter_tips_long', 'access' => TRUE,
      'type' => MENU_SUGGESTED_ITEM);
  }
  else {
    if (arg(0) == 'admin' && arg(1) == 'filters' && is_numeric(arg(2))) {
      $formats = filter_formats();

      if (isset($formats[arg(2)])) {
        $items[] = array('path' => 'admin/filters/'. arg(2), 'title' => t("'%format' input format", array('%format' => $formats[arg(2)]->name)),
        'callback' => 'filter_admin_filters',
        'type' => MENU_CALLBACK,
        'access' => user_access('administer filters'));

        $items[] = array('path' => 'admin/filters/'. arg(2) .'/list', 'title' => t('list'),
        'callback' => 'filter_admin_filters',
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => 0,
        'access' => user_access('administer filters'));

        $items[] = array('path' => 'admin/filters/'. arg(2) .'/configure', 'title' => t('configure'),
        'callback' => 'filter_admin_configure',
        'type' => MENU_LOCAL_TASK,
        'weight' => 1,
        'access' => user_access('administer filters'));

        $items[] = array('path' => 'admin/filters/'. arg(2) .'/order', 'title' => t('rearrange'),
        'callback' => 'filter_admin_order',
        'type' => MENU_LOCAL_TASK,
        'weight' => 2,
        'access' => user_access('administer filters'));
      }
    }
  }

  return $items;
}

/**
 * Implementation of hook_perm().
 */
function filter_perm() {
  return array('administer filters');
}

/**
 * Menu callback; allows administrators to set up input formats.
 */
function filter_admin_overview() {
  // Process form submission
  switch ($_POST['op']) {
    case t('Save input formats'):
      filter_admin_save();
      break;
    case t('Add input format'):
      filter_admin_add();
      break;
  }

  // Overview of all formats.
  $formats = filter_formats();
  $roles = user_roles();
  $error = false;

  $header = array(t('Name'), t('Default'));
  foreach ($roles as $name) {
    $header[] = $name;
  }
  $header[] = array('data' => t('Operations'), 'colspan' => 2);

  $rows = array();
  foreach ($formats as $id => $format) {
    $row = array();
    $default = ($id == variable_get('filter_default_format', 1));

    $row[] = form_textfield('', "name][$id", $format->name, 16, 255);
    $row[] = form_radio('', 'default', $id, $default);

    foreach ($roles as $rid => $name) {
      $checked = strstr($format->roles, ",$rid,");
      $row[] = form_checkbox('', "roles][$id][$rid", 1, $default || $checked, NULL, $default ? array('disabled' => 'disabled') : NULL);
    }

    $row[] = l(t('configure'), 'admin/filters/'. $id);
    $row[] = $default ? '' : l('delete', 'admin/filters/delete/'. $id);

    $rows[] = $row;
  }

  $group = theme('table', $header, $rows);
  $group .= form_submit(t('Save input formats'));
  $output = '<h2>'. t('Permissions and settings') . '</h2>' . form($group);

  // Form to add a new format.
  $group = t("<p>To add a new input format, type its name here. After it has been added, you can configure its options.</p>");
  $form = form_textfield(t('Name'), 'name', '', 40, 255);
  $form .= form_submit(t('Add input format'));
  $group .= form($form);
  $output .= '<h2>'. t('Add new input format') .'</h2>'. $group;

  print theme('page', $output);
}

/**
 * Save input formats on the overview page.
 */
function filter_admin_save() {
  $edit = $_POST['edit'];

  variable_set('filter_default_format', $edit['default']);

  foreach ($edit['name'] as $id => $name) {
    $name = trim($name);

    if (strlen($name) == 0) {
      drupal_set_message(t('You must enter a name for this input format.'));
      drupal_goto('admin/filters');
    }
    else {
      db_query("UPDATE {filter_formats} SET name='%s' WHERE format = %d", $name, $id);
    }
  }

  // We store the roles as a string for ease of use.
  // We use leading and trailing comma's to allow easy substring matching.
  foreach ($edit['roles'] as $id => $format) {
    $roles = ',';
    foreach ($format as $rid => $value) {
      if ($value) {
        $roles .= $rid .',';
      }
    }
    db_query("UPDATE {filter_formats} SET roles = '%s' WHERE format = %d", $roles, $id);
  }

  drupal_set_message(t('The input format settings have been updated.'));
  drupal_goto('admin/filters');
}

/**
 * Add a new input format.
 */
function filter_admin_add() {
  $edit = $_POST['edit'];

  $name = trim($edit['name']);

  if (strlen($name) == 0) {
    drupal_set_message(t('You must enter a name for this input format.'));
    drupal_goto('admin/filters');
  }
  else {
    db_query("INSERT INTO {filter_formats} (name) VALUES ('%s')", $name);
  }

  drupal_set_message(t('Added input format %format.', array('%format' => theme('placeholder', $edit['name']))));
  drupal_goto('admin/filters');
}

/**
 * Menu callback; confirm deletion of a format.
 */
function filter_admin_delete() {
  $edit = $_POST['edit'];
  if ($edit['confirm']) {
    if ($edit['format'] != variable_get('filter_default_format', 1)) {
      db_query("DELETE FROM {filter_formats} WHERE format = %d", $edit['format']);
      db_query("DELETE FROM {filters} WHERE format = %d", $edit['format']);

      $default = variable_get('filter_default_format', 1);
      db_query("UPDATE {node} SET format = %d WHERE format = %d", $default, $edit['format']);
      db_query("UPDATE {comments} SET format = %d WHERE format = %d", $default, $edit['format']);
      db_query("UPDATE {boxes} SET format = %d WHERE format = %d", $default, $edit['format']);

      cache_clear_all('filter:'. $edit['format'], true);

      drupal_set_message(t('Deleted input format %format.', array('%format' => theme('placeholder', $edit['name']))));
    }
    drupal_goto('admin/filters');
  }

  $format = arg(3);
  $format = db_fetch_object(db_query('SELECT * FROM {filter_formats} WHERE format = %d', $format));

  $extra  = form_hidden('format', $format->format);
  $extra .= form_hidden('name', $format->name);
  $output = theme('confirm',
                  t('Are you sure you want to delete the input format %format?', array('%format' => theme('placeholder', $format->name))),
                  'admin/filters',
                  t('If you have any content left in this input format, it will be switched to the default input format. This action cannot be undone.'),
                  t('Delete'),
                  t('Cancel'),
                  $extra);
  print theme('page', $output);
}

/**
 * Menu callback; configure the filters for a format.
 */
function filter_admin_filters() {
  $format = arg(2);

  // Handle saving of weights.
  if ($_POST['op']) {
    filter_admin_filters_save($format, $_POST['edit']);
  }

  $all = filter_list_all();
  $enabled = filter_list_format($format);

  // Table with filters
  $header = array(t('Enabled'), t('Name'), t('Description'));
  $rows = array();
  foreach ($all as $id => $filter) {
    $row = array();
    $row[] = form_checkbox('', $id, 1, isset($enabled[$id]));
    $row[] = $filter->name;
    $row[] = module_invoke($filter->module, 'filter', 'description', $filter->delta);

    $rows[] = $row;
  }
  $form = theme('table', $header, $rows);
  if (!$empty) {
    $form .= form_submit(t('Save configuration'));
  }

  $output .= '<h2>'. t('Filters') .'</h2>'. form($form);

  // Composition tips (guidelines)
  $tips = _filter_tips($format, false);
  $extra = l(t('More information about formatting options'), 'filter/tips');
  $tiplist = theme('filter_tips', $tips, false, $extra);
  if (!$tiplist) {
    $tiplist = t('<p>No guidelines available.</p>');
  }
  $group = t('<p>These are the guidelines that users will see for posting in this input format. They are automatically generated from the filter settings.</p>');
  $group .= $tiplist;
  $output .= '<h2>'. t('Formatting guidelines') .'</h2>'. $group;

  print theme('page', $output);
}

/**
 * Save enabled/disabled status for filters in a format.
 */
function filter_admin_filters_save($format, $toggles) {
  $current = filter_list_format($format);

  $cache = true;

  db_query("DELETE FROM {filters} WHERE format = %d", $format);
  foreach ($toggles as $id => $checked) {
    if ($checked) {
      list($module, $delta) = explode('/', $id);
      // Add new filters to the bottom
      $weight = isset($current[$id]->weight) ? $current[$id]->weight : 10;
      db_query("INSERT INTO {filters} (format, module, delta, weight) VALUES (%d, '%s', %d, %d)", $format, $module, $delta, $weight);

      // Check if there are any 'no cache' filters
      $cache &= !module_invoke($module, 'filter', 'no cache', $delta);
    }
  }

  // Update the format's 'no cache' flag.
  db_query('UPDATE {filter_formats} SET cache = %d WHERE format = %d', (int)$cache, $format);

  cache_clear_all('filter:'. $format, true);

  drupal_set_message(t('The input format has been updated.'));
  drupal_goto('admin/filters/'. arg(2) .'/list');
}

/**
 * Menu callback; display form for ordering filters for a format.
 */
function filter_admin_order() {
  $format = arg(2);
  if ($_POST['op']) {
    filter_admin_order_save($format, $_POST['edit']);
  }

  // Get list (with forced refresh)
  $filters = filter_list_format($format);

  $header = array(t('Name'), t('Weight'));
  $rows = array();

  foreach ($filters as $id => $filter) {
    $rows[] = array($filter->name, form_weight('', $id, $filter->weight));
  }

  $form  = theme('table', $header, $rows);
  $form .= form_submit(t('Save configuration'));
  $output = form($form);

  print theme('page', $output);
}

/**
 * Save the weights of filters in a format.
 */
function filter_admin_order_save($format, $weights) {
  foreach ($weights as $id => $weight) {
    list($module, $delta) = explode('/', $id);
    db_query("UPDATE {filters} SET weight = %d WHERE format = %d AND module = '%s' AND delta = %d", $weight, $format, $module, $delta);
  }
  drupal_set_message(t('The filter weights have been saved.'));

  cache_clear_all('filter:'. $format, true);

  drupal_goto('admin/filters/'. arg(2) .'/order');
}

/**
 * Menu callback; display settings defined by filters.
 */
function filter_admin_configure() {
  $format = arg(2);

  system_settings_save();

  $list = filter_list_format($format);
  $form = "";
  foreach ($list as $filter) {
    $form .= module_invoke($filter->module, 'filter', 'settings', $filter->delta, $format);
  }

  if (trim($form) != '') {
    $output = system_settings_form($form);
  }
  else {
    $output = t('No settings are available.');
  }

  print theme('page', $output);
}

/**
 * Retrieve a list of input formats.
 */
function filter_formats() {
  global $user;
  static $formats;

  // Administrators can always use all input formats.
  $all = user_access('administer filters');

  if (!isset($formats)) {
    $formats = array();

    $query = 'SELECT * FROM {filter_formats}';

    // Build query for selecting the format(s) based on the user's roles.
    if (!$all) {
      $where = array();
      foreach ($user->roles as $rid => $role) {
        $where[] = "roles LIKE '%%,%d,%%'";
        $args[] = $rid;
      }
      $query .= ' WHERE '. implode(' OR ', $where) . ' OR format = %d';
      $args[] = variable_get('filter_default_format', 1);
    }

    $result = db_query($query, $args);
    while ($format = db_fetch_object($result)) {
      $formats[$format->format] = $format;
    }
  }
  return $formats;
}

/**
 * Build a list of all filters.
 */
function filter_list_all() {
  $filters = array();

  foreach (module_list() as $module) {
    $list = module_invoke($module, 'filter', 'list');
    if (is_array($list)) {
      foreach ($list as $delta => $name) {
        $filters[$module .'/'. $delta] = (object)array('module' => $module, 'delta' => $delta, 'name' => $name);
      }
    }
  }

  uasort($filters, '_filter_list_cmp');

  return $filters;
}

/**
 * Helper function for sorting the filter list by filter name.
 */
function _filter_list_cmp($a, $b) {
  return strcmp($a->name, $b->name);
}

/**
 * Check if text in a certain input format is allowed to be cached.
 */
function filter_format_allowcache($format) {
  static $cache = array();

  if (!isset($cache[$format])) {
    $cache[$format] = db_result(db_query('SELECT cache FROM {filter_formats} WHERE format = %d', $format));
  }
  return $cache[$format];
}

/**
 * Retrieve a list of filters for a certain format.
 */
function filter_list_format($format) {
  static $filters = array();

  if (!isset($filters[$format])) {
    $filters[$format] = array();
    $result = db_query("SELECT * FROM {filters} WHERE format = %d ORDER BY weight ASC", $format);
    while ($filter = db_fetch_object($result)) {
      $list = module_invoke($filter->module, 'filter', 'list');
      if (is_array($list) && isset($list[$filter->delta])) {
        $filter->name = $list[$filter->delta];
        $filters[$format][$filter->module .'/'. $filter->delta] = $filter;
      }
    }
  }

  return $filters[$format];
}

/**
 * @name Filtering functions
 * @{
 * Modules which need to have content filtered can use these functions to
 * interact with the filter system.
 *
 * For more info, see the hook_filter() documentation.
 *
 * Note: because filters can inject JavaScript or execute PHP code, security is
 * vital here. When a user supplies a $format, you should validate it with
 * filter_access($format) before accepting/using it. This is normally done in
 * the validation stage of the node system. You should for example never make a
 * preview of content in a disallowed format.
 */

/**
 * Run all the enabled filters on a piece of text.
 *
 * You can do a filter_access() check on $format automatically by passing
 * $check = TRUE. Note that this will check the permissions of the current user,
 * so you should specify $check = FALSE when viewing other people's content.
 *
 * @param $text
 *    The text to be filtered.
 * @param $format
 *    The format of the text to be filtered. Specify FILTER_FORMAT_DEFAULT for
 *    the default format.
 * @param $check
 *    Whether to check the $format with filter_access() first. If set to false,
 *    make sure the check has performed at some point earlier.
 */
function check_output($text, $format = FILTER_FORMAT_DEFAULT, $check = FALSE) {
  // When $check = true, do an access check on $format.
  if (isset($text) && (!$check || filter_access($format))) {
    if ($format == FILTER_FORMAT_DEFAULT) {
      $format = variable_get('filter_default_format', 1);
    }

    // Check for a cached version of this piece of text.
    $id = 'filter:'. $format .':'. md5($text);
    if ($cached = cache_get($id)) {
      return $cached->data;
    }

    // See if caching is allowed for this format.
    $cache = filter_format_allowcache($format);

    // Convert all Windows and Mac newlines to a single newline,
    // so filters only need to deal with one possibility.
    $text = str_replace(array("\r\n", "\r"), "\n", $text);

    // Get a complete list of filters, ordered properly.
    $filters = filter_list_format($format);

    // Give filters the chance to escape HTML-like data such as code or formulas.
    foreach ($filters as $filter) {
      $text = module_invoke($filter->module, 'filter', 'prepare', $filter->delta, $format, $text);
    }

    // Perform filtering.
    foreach ($filters as $filter) {
      $text = module_invoke($filter->module, 'filter', 'process', $filter->delta, $format, $text);
    }

    // Store in cache with a minimum expiration time of 1 day.
    if ($cache) {
      cache_set($id, $text, time() + (60 * 60 * 24));
    }
  }
  else {
    $text = message_na();
  }

  return $text;
}

/**
 * Generate a selector for choosing a format in a form.
 *
 * @param $name
 *   The internal name used to refer to the form element.
 * @param $value
 *   The ID of the format that is currently selected.
 * @return
 *   HTML for the form element.
 */
function filter_form($name = 'format', $value = FILTER_FORMAT_DEFAULT) {
  if ($value == FILTER_FORMAT_DEFAULT) {
    $value = variable_get('filter_default_format', 1);
  }
  $formats = filter_formats();

  $extra = l(t('More information about formatting options'), 'filter/tips');

  if (count($formats) > 1) {
    // Multiple formats available: display radio buttons with tips.
    $output = '';
    foreach ($formats as $format) {
      $tips = _filter_tips($format->format, false);

      // TODO: get support for block-level radios so the <br /> is not output?
      $output .= '<div>';
      $output .= '<label class="option"><input type="radio" class="form-radio" name="edit['. $name .']" value="'. $format->format .'"'. ($format->format == $value ? ' checked="checked"' : '') .' /> '. $format->name .'</label>';
      $output .= theme('filter_tips', $tips);
      $output .= '</div>';
    }
    return theme('form_element', t('Input format'), $output, $extra, NULL, _form_get_error($name));
  }
  else {
    // Only one format available: use a hidden form item and only show tips.
    $format = array_shift($formats);
    $output = form_hidden($name, $format->format);
    $tips = _filter_tips(variable_get('filter_default_format', 1), false);
    $output .= form_item(t('Formatting guidelines'), theme('filter_tips', $tips, false, $extra), $extra);
    return $output;
  }
}

/**
 * Returns true if the user is allowed to access this format.
 */
function filter_access($format) {
  if (user_access('administer filters') || ($format == FILTER_FORMAT_DEFAULT) || ($format == variable_get('filter_default_format', 1))) {
    return true;
  }
  else {
    $formats = filter_formats();
    return isset($formats[$format]);
  }
}
/**
 * @} End of "Filtering functions".
 */

/**
 * Menu callback; show a page with long filter tips.
 */
function filter_tips_long() {
  $format = arg(2);
  if ($format) {
    $output = theme('filter_tips', _filter_tips($format, true), true);
  }
  else {
    $output = theme('filter_tips', _filter_tips(-1, true), true);
  }
  print theme('page', $output);
}

/**
 * Helper function for fetching filter tips.
 */
function _filter_tips($format, $long = false) {
  if ($format == -1) {
    $formats = filter_formats();
  }
  else {
    $formats = array(db_fetch_object(db_query("SELECT * FROM {filter_formats} WHERE format = %d", $format)));
  }

  $tips = array();

  foreach ($formats as $format) {
    $filters = filter_list_format($format->format);

    $tips[$format->name] = array();
    foreach ($filters as $id => $filter) {
      if ($tip = module_invoke($filter->module, 'filter_tips', $filter->delta, $format->format, $long)) {
        $tips[$format->name][] = array('tip' => $tip, 'id' => $id);
      }
    }
  }

  return $tips;
}

/**
 * Format a set of filter tips.
 *
 * @ingroup themeable
 */
function theme_filter_tips($tips, $long = false, $extra = '') {
  $output = '';

  $multiple = count($tips) > 1;
  if ($multiple) {
    $output = t('Input formats') .':';
  }

  if (count($tips)) {
    if ($multiple) {
      $output .= '<ul>';
    }
    foreach ($tips as $name => $tiplist) {
      if ($multiple) {
        $output .= '<li>';
        $output .= '<strong>'. $name .'</strong>:<br />';
      }

      $tips = '';
      foreach ($tiplist as $tip) {
        $tips .= '<li'. ($long ? ' id="filter-'. str_replace("/", "-", $tip['id']) .'">' : '>') . $tip['tip'] . '</li>';
      }

      if ($tips) {
        $output .= "<ul class=\"tips\">$tips</ul>";
      }

      if ($multiple) {
        $output .= '</li>';
      }
    }
    if ($multiple) {
      $output .= '</ul>';
    }
  }

  return $output;
}

/**
 * @name Standard filters
 * @{
 * Filters implemented by the filter.module.
 */

/**
 * Implementation of hook_filter(). Contains a basic set of essential filters.
 * - HTML filter:
 *     Validates user-supplied HTML, transforming it as necessary.
 * - PHP evaluator:
 *     Executes PHP code.
 * - Line break converter:
 *     Converts newlines into paragraph and break tags.
 */
function filter_filter($op, $delta = 0, $format = -1, $text = '') {
  switch ($op) {
    case 'list':
      return array(0 => t('HTML filter'), 1 => t('PHP evaluator'), 2 => t('Line break converter'));

    case 'no cache':
      return $delta == 1; // No caching for the PHP evaluator.

    case 'description':
      switch ($delta) {
        case 0:
          return t('Allows you to restrict if users can post HTML and which tags to filter out.');
        case 1:
          return t('Runs a piece of PHP code. The usage of this filter should be restricted to administrators only!');
        case 2:
          return t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt; tags).');
        default:
          return;
      }

    case 'process':
      switch ($delta) {
        case 0:
          return _filter_html($text, $format);
        case 1:
          return drupal_eval($text);
        case 2:
          return _filter_autop($text);
        default:
          return $text;
      }

    case 'settings':
      switch ($delta) {
        case 0:
          return _filter_html_settings($format);
        default:
          return;
      }

    default:
      return $text;
  }
}

/**
 * Settings for the HTML filter.
 */
function _filter_html_settings($format) {
  $group = form_radios(t('Filter HTML tags'), "filter_html_$format", variable_get("filter_html_$format", FILTER_HTML_STRIP), array(FILTER_HTML_STRIP => t('Strip disallowed tags'), FILTER_HTML_ESCAPE => t('Escape tags')), t('How to deal with HTML tags in user-contributed content. If set to "Strip disallowed tags", dangerous tags are removed (see below).  If set to "Escape tags", all HTML is escaped and presented as it was typed.'));
  $group .= form_textfield(t('Allowed HTML tags'), "allowed_html_$format", variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'), 64, 255, t('If "Strip tags" is selected, optionally specify tags which should not be stripped. Javascript event attributes are always stripped.'));
  $group .= form_checkbox(t('Display HTML help'), "filter_html_help_$format", 1, variable_get("filter_html_help_$format", 1), t('If enabled, Drupal will display some basic HTML help in the long filter tips.'));
  $group .= form_checkbox(t('Spam link deterrent'), "filter_html_nofollow_$format", 1, variable_get("filter_html_nofollow_$format", FALSE), t('If enabled, Drupal will add rel="nofollow" to all links, as a measure to reduce the effectiveness of spam links. Note: this will also prevent valid links from being followed by search engines, therefore it is likely most effective when enabled for anonymous users.'));
  $output .= form_group(t('HTML filter'), $group);

  return $output;
}

/**
 * HTML filter. Provides filtering of input into accepted HTML.
 */
function _filter_html($text, $format) {
  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_STRIP) {
    $allowed_tags = preg_split('/\s+|<|>/', variable_get("allowed_html_$format", '<a> <em> <strong> <cite> <code> <ul> <ol> <li> <dl> <dt> <dd>'), -1, PREG_SPLIT_NO_EMPTY);
    $text = filter_xss($text, $allowed_tags);
  }

  if (variable_get("filter_html_$format", FILTER_HTML_STRIP) == FILTER_HTML_ESCAPE) {
    // Escape HTML
    $text = check_plain($text);
  }

  if (variable_get("filter_html_nofollow_$format", FALSE)) {
    $text = preg_replace('/<a([^>]+)>/i', '<a\\1 rel="nofollow">', $text);
  }

  return trim($text);
}

/**
 * Convert line breaks into <p> and <br> in an intelligent fashion.
 * Based on: http://photomatt.net/scripts/autop
 */
function _filter_autop($text) {
  // All block level tags
  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6])';
  
  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.
  // We don't apply any processing to the contents of these tags to avoid messing
  // up code. We look for matched pairs and allow basic nesting. For example:
  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"
  $chunks = preg_split('@(</?(?:pre|script|style)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and literals
  // and begins and ends with a literal (inserting NULL as required).
  $ignore = false;
  $ignoretag = '';
  $output = '';
  foreach ($chunks as $i => $chunk) {
    if ($i % 2) {
      // Opening or closing tag?
      $open = ($chunk{1} != '/');
      list($tag) = split('[ >]', substr($chunk, 2 - $open), 2);
      if (!$ignore) {
        if ($open) {
          $ignore = true;
          $ignoretag = $tag;
        }
      }
      // Only allow a matching tag to close it.
      else if (!$open && $ignoretag == $tag) {
        $ignore = false;
        $ignoretag = '';
      }
    }
    else if (!$ignore) {
      $chunk = preg_replace('|\n*$|', '', $chunk) ."\n\n"; // just to make things a little easier, pad the end
      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);
      $chunk = preg_replace('!(<'. $block .'[^>]*>)!', "\n$1", $chunk); // Space things out a little
      $chunk = preg_replace('!(</'. $block .'>)!', "$1\n\n", $chunk); // Space things out a little
      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates
      $chunk = preg_replace('/\n?(.+?)(?:\n\s*\n|\z)/s', "<p>$1</p>\n", $chunk); // make paragraphs, including one at the end
      $chunk = preg_replace('|<p>\s*?</p>|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace
      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists
      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);
      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);
      $chunk = preg_replace('!<p>\s*(</?'. $block .'[^>]*>)!', "$1", $chunk);
      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*</p>!', "$1", $chunk);
      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks
      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*<br />!', "$1", $chunk);
      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);
      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{0,7};)/', '&amp;$1', $chunk);
    }
    $output .= $chunk;
  }
  return $output;
}

/**
 * Filters XSS. Based on kses by Ulf Harnhammar, see
 * http://sourceforge.net/projects/kses
 *
 * For examples of various XSS attacks, see:
 * http://ha.ckers.org/xss.html
 *
 * This code does four things:
 * - Removes characters and constructs that can trick browsers
 * - Makes sure all HTML entities are well-formed
 * - Makes sure all HTML tags and attributes are well-formed
 * - Makes sure no HTML tags contain URLs with a disallowed protocol (e.g. javascript:)
 *
 * @param $string
 *   The string with raw HTML in it. It will be stripped of everything that can cause
 *   an XSS attack.
 * @param $allowed_tags
 *   An array of allowed tags.
 * @param $format
 *   The format to use.
 */
function filter_xss($string, $allowed_tags = array('a', 'em', 'strong', 'cite', 'code', 'ul', 'ol', 'li', 'dl', 'dt', 'dd')) {
  // Store the input format
  _filter_xss_split($allowed_tags, TRUE);
  // Remove NUL characters (ignored by some browsers)
  $string = str_replace(chr(0), '', $string);
  // Remove Netscape 4 JS entities
  $string = preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $string);

  // Defuse all HTML entities
  $string = str_replace('&', '&amp;', $string);
  // Change back only well-formed entities in our whitelist
  // Named entities
  $string = preg_replace('/&amp;([A-Za-z][A-Za-z0-9]*;)/', '&\1', $string);
  // Decimal numeric entities
  $string = preg_replace('/&amp;#0*([0-9]+;)/', '&#\1', $string);
  // Hexadecimal numeric entities
  $string = preg_replace('/&amp;#[Xx]0*((?:[0-9A-Fa-f]{2})+;)/', '&#x\1', $string);

  return preg_replace_callback('%
    (
    <[^>]*.(>|$)  # a string that starts with a <, up until the > or the end of the string
    |             # or
    >             # just a >
    )%x', '_filter_xss_split', $string);
}

/**
 * Processes an HTML tag.
 *
 * @param @m
 *   An array with various meaning depending on the value of $store.
 *   If $store is TRUE then the array contains the allowed tags.
 *   If $store is FALSE then the array has one element, the HTML tag to process.
 * @param $store
 *   Whether to store $m.
 * @return
 *   If the element isn't allowed, an empty string. Otherwise, the cleaned up
 *   version of the HTML element.
 */
function _filter_xss_split($m, $store = FALSE) {
  static $allowed_html;

  if ($store) {
    $allowed_html = array_flip($m);
    return;
  }

  $string = $m[1];

  if (substr($string, 0, 1) != '<') {
    // We matched a lone ">" character
    return '&gt;';
  }

  if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches)) {
    // Seriously malformed
    return '';
  }

  $slash = trim($matches[1]);
  $elem = &$matches[2];
  $attrlist = &$matches[3];

  if (!isset($allowed_html[strtolower($elem)])) {
    // Disallowed HTML element
    return '';
  }

  if ($slash != '') {
    return "</$elem>";
  }
  // Is there a closing XHTML slash at the end of the attributes?
  $xhtml_slash = preg_match('%\s/\s*$%', $attr) ? '/' : '';

  // Clean up attributes
  $attr2 = implode(' ', _filter_xss_attributes($attrlist));
  $attr2 = preg_replace('/[<>]/', '', $attr2);

  return "<$elem $attr2$xhtml_slash>";
}

/**
 * Processes a string of HTML attributes.
 *
 * @return
 *   Cleaned up version of the HTML attributes.
 */
function _filter_xss_attributes($attr) {
  $attrarr = array();
  $mode = 0;
  $attrname = '';

  while (strlen($attr) != 0) {
    // Was the last operation successful?
    $working = 0;

    switch ($mode) {
      case 0:
        // Attribute name, href for instance
        if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {
          $attrname = strtolower($match[1]);
          $skip = ($attrname == 'style' || substr($attrname, 0, 2) == 'on');
          $working = $mode = 1;
          $attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);
        }

        break;

      case 1:
        // Equals sign or valueless ("selected")
        if (preg_match('/^\s*=\s*/', $attr)) {
          $working = 1; $mode = 2;
          $attr = preg_replace('/^\s*=\s*/', '', $attr);
          break;
        }

        if (preg_match('/^\s+/', $attr)) {
          $working = 1; $mode = 0;
          if (!$skip) {
            $attrarr[] = $attrname;
          }
          $attr = preg_replace('/^\s+/', '', $attr);
        }

        break;

      case 2:
        // Attribute value, a URL after href= for instance
        if (preg_match('/^"([^"]*)"(\s+|$)/', $attr, $match)) {
          $thisval = filter_xss_bad_protocol($match[1]);

          if (!$skip) {
            $attrarr[] = "$attrname=\"$thisval\"";
          }
          $working = 1;
          $mode = 0;
          $attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);
          break;
        }

        if (preg_match("/^'([^']*)'(\s+|$)/", $attr, $match)) {
          $thisval = filter_xss_bad_protocol($match[1]);

          if (!$skip) {
            $attrarr[] = "$attrname='$thisval'";;
          }
          $working = 1; $mode = 0;
          $attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);
          break;
        }

        if (preg_match("%^([^\s\"']+)(\s+|$)%", $attr, $match)) {
          $thisval = filter_xss_bad_protocol($match[1]);

          if (!$skip) {
            $attrarr[] = "$attrname=\"$thisval\"";
          }
          $working = 1; $mode = 0;
          $attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);
        }

        break;
    }

    if ($working == 0) {
      // not well formed, remove and try again
      $attr = preg_replace('/
        ^
        (
        "[^"]*("|$)     # - a string that starts with a double quote, up until the next double quote or the end of the string
        |               # or
        \'[^\']*(\'|$)| # - a string that starts with a quote, up until the next quote or the end of the string
        |               # or
        \S              # - a non-whitespace character
        )*              # any number of the above three
        \s*             # any number of whitespaces
        /x', '', $attr);
      $mode = 0;
    }
  }

  // the attribute list ends with a valueless attribute like "selected"
  if ($mode == 1) {
    $attrarr[] = $attrname;
  }
  return $attrarr;
}

/**
 * Processes an HTML attribute value and ensures it does not contain an URL
 * with a disallowed protocol (e.g. javascript:)
 *
 * @param $string
 *   The string with the attribute value.
 * @param $decode
 *   Whether to decode entities in the $string. Set to FALSE if the $string
 *   is in plain text, TRUE otherwise. Defaults to TRUE.
 * @return
 *   Cleaned up and HTML-escaped version of $string.
 */
function filter_xss_bad_protocol($string, $decode = TRUE) {
  static $allowed_protocols;
  if (!isset($allowed_protocols)) {
    $allowed_protocols = array_flip(variable_get('filter_allowed_protocols', array('http', 'https', 'ftp', 'news', 'nntp', 'telnet', 'mailto', 'irc', 'ssh', 'sftp', 'webcal')));
  }

  // Get the plain text representation of the attribute value (i.e. its meaning)
  if ($decode) {
    $string = decode_entities($string);
  }

  // Iteratively remove any invalid protocol found.
  do {
    $before = $string;
    $colonpos = strpos($string, ':');
    if ($colonpos > 0) {
      // We found a colon, possibly a protocol. Verify.
      $protocol = substr($string, 0, $colonpos);
      // If a colon is preceded by a slash, question mark or hash, it cannot
      // possibly be part of the URL scheme. This must be a relative URL,
      // which inherits the (safe) protocol of the base document.
      if (preg_match('![/?#]!', $protocol)) {
        break;
      }
      // Check if this is a disallowed protocol
      if (!isset($allowed_protocols[$protocol])) {
        $string = substr($string, $colonpos + 1);
      }
    }
  } while ($before != $string);
  return check_plain($string);
}

/**
 * @} End of "Standard filters".
 */

?>
