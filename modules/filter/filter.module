<?php
// $Id$

/**
 * @file
 * Framework for handling filtering of content.
 */

/**
 * Implement hook_help().
 */
function filter_help($path, $arg) {
  switch ($path) {
    case 'admin/help#filter':
      $output = '<p>' . t("The filter module allows administrators to configure text formats for use on your site. A text format defines the HTML tags, codes, and other input allowed in both content and comments, and is a key feature in guarding against potentially damaging input from malicious users. Two formats included by default are <em>Filtered HTML</em> (which allows only an administrator-approved subset of HTML tags) and <em>Full HTML</em> (which allows the full set of HTML tags). Additional formats may be created by an administrator.") . '</p>';
      $output .= '<p>' . t('Each text format uses filters to manipulate text, and most formats apply several different filters to text in a specific order. Each filter is designed for a specific purpose, and generally either adds, removes or transforms elements within user-entered text before it is displayed. A filter does not change the actual content of a post, but instead, modifies it temporarily before it is displayed. A filter may remove unapproved HTML tags, for instance, while another automatically adds HTML to make links referenced in text clickable.') . '</p>';
      $output .= '<p>' . t('Users with access to more than one text format can use the <em>Text format</em> fieldset to choose between available text formats when creating or editing multi-line content. Administrators determine the text formats available to each user role and control the order of formats listed in the <em>Text format</em> fieldset.') . '</p>';
      $output .= '<p>' . t('For more information, see the online handbook entry for <a href="@filter">Filter module</a>.', array('@filter' => 'http://drupal.org/handbook/modules/filter/')) . '</p>';
      return $output;
    case 'admin/config/content/formats':
      $output = '<p>' . t('Use the list below to review the text formats available to each user role and to control the order of formats listed in the <em>Text format</em> fieldset. (The <em>Text format</em> fieldset is displayed below textareas when users with access to more than one text format create multi-line content.) All text formats are available to users in roles with the "administer filters" permission, and the special %fallback format is available to all users. You can configure access to other text formats on the <a href="@url">permissions page</a>.', array('%fallback' => filter_fallback_format_title(), '@url' => url('admin/config/people/permissions', array('fragment' => 'module-filter')))) . '</p>';
      $output .= '<p>' . t('Since text formats, if available, are presented in the same order as the list below, and the default format for each user is the first one on the list for which that user has access, it may be helpful to arrange the formats in descending order of your preference for their use. Remember that your changes will not be saved until you click the <em>Save changes</em> button at the bottom of the page.') . '</p>';
      return $output;
    case 'admin/config/content/formats/%':
      return '<p>' . t('Every <em>filter</em> performs one particular change on the user input, for example stripping out malicious HTML or making URLs clickable. Choose which filters you want to apply to text in this format. If you notice some filters are causing conflicts in the output, you can <a href="@rearrange">rearrange them</a>.', array('@rearrange' => url('admin/config/content/formats/' . $arg[4] . '/order'))) . '</p>';
    case 'admin/config/content/formats/%/configure':
      return '<p>' . t('If you cannot find the settings for a certain filter, make sure you have enabled it on the <a href="@url">edit tab</a> first.', array('@url' => url('admin/config/content/formats/' . $arg[4]))) . '</p>';
    case 'admin/config/content/formats/%/order':
      $output = '<p>' . t('Because of the flexible filtering system, you might encounter a situation where one filter prevents another from doing its job. For example: a word in an URL gets converted into a glossary term, before the URL can be converted to a clickable link. When this happens, rearrange the order of the filters.') . '</p>';
      $output .= '<p>' . t("Filters are executed from top-to-bottom. To change the order of the filters, modify the values in the <em>Weight</em> column or grab a drag-and-drop handle under the <em>Name</em> column and drag filters to new locations in the list. (Grab a handle by clicking and holding the mouse while hovering over a handle icon.) Remember that your changes will not be saved until you click the <em>Save configuration</em> button at the bottom of the page.") . '</p>';
      return $output;
  }
}

/**
 * Implement hook_theme().
 */
function filter_theme() {
  return array(
    'filter_admin_overview' => array(
      'arguments' => array('form' => NULL),
      'file' => 'filter.admin.inc',
    ),
    'filter_admin_order' => array(
      'arguments' => array('form' => NULL),
      'file' => 'filter.admin.inc',
    ),
    'filter_tips' => array(
      'arguments' => array('tips' => NULL, 'long' => FALSE),
      'file' => 'filter.pages.inc',
    ),
    'filter_tips_more_info' => array(
      'arguments' => array(),
    ),
    'filter_guidelines' => array(
      'arguments' => array('format' => NULL),
    ),
  );
}

/**
 * Implement hook_menu().
 */
function filter_menu() {
  $items['filter/tips'] = array(
    'title' => 'Compose tips',
    'page callback' => 'filter_tips_long',
    'access callback' => TRUE,
    'type' => MENU_SUGGESTED_ITEM,
    'file' => 'filter.pages.inc',
  );
  $items['admin/config/content/formats'] = array(
    'title' => 'Text formats',
    'description' => 'Configure how content input by users is filtered, including allowed HTML tags. Also allows enabling of module-provided filters.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('filter_admin_overview'),
    'access arguments' => array('administer filters'),
    'file' => 'filter.admin.inc',
  );
  $items['admin/config/content/formats/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/content/formats/add'] = array(
    'title' => 'Add text format',
    'page callback' => 'filter_admin_format_page',
    'access arguments' => array('administer filters'),
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
    'file' => 'filter.admin.inc',
  );
  $items['admin/config/content/formats/%filter_format'] = array(
    'type' => MENU_CALLBACK,
    'title callback' => 'filter_admin_format_title',
    'title arguments' => array(4),
    'page callback' => 'filter_admin_format_page',
    'page arguments' => array(4),
    'access arguments' => array('administer filters'),
    'file' => 'filter.admin.inc',
  );
  $items['admin/config/content/formats/%filter_format/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/config/content/formats/%filter_format/configure'] = array(
    'title' => 'Configure',
    'page callback' => 'filter_admin_configure_page',
    'page arguments' => array(4),
    'access arguments' => array('administer filters'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'filter.admin.inc',
  );
  $items['admin/config/content/formats/%filter_format/order'] = array(
    'title' => 'Rearrange',
    'page callback' => 'filter_admin_order_page',
    'page arguments' => array(4),
    'access arguments' => array('administer filters'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'filter.admin.inc',
  );
  $items['admin/config/content/formats/%filter_format/delete'] = array(
    'title' => 'Delete text format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('filter_admin_delete', 4),
    'access callback' => '_filter_delete_format_access',
    'access arguments' => array(4),
    'type' => MENU_CALLBACK,
    'file' => 'filter.admin.inc',
  );
  return $items;
}

/**
 * Access callback for deleting text formats.
 *
 * @param $format
 *   A text format object.
 * @return
 *   TRUE if the text format can be deleted by the current user, FALSE
 *   otherwise.
 */
function _filter_delete_format_access($format) {
  // The fallback format can never be deleted.
  return user_access('administer filters') && ($format->format != filter_fallback_format());
}

/**
 * Load a text format object from the database.
 *
 * @param $format_id
 *   The format ID.
 *
 * @return
 *   A fully-populated text format object.
 */
function filter_format_load($format_id) {
  $formats = filter_formats();
  return isset($formats[$format_id]) ? $formats[$format_id] : FALSE;
}

/**
 * Save a text format object to the database.
 *
 * @param $format
 *   A format object using the properties:
 *   - 'name': The title of the text format.
 *   - 'format': (optional) The internal ID of the text format. If omitted, a
 *     new text format is created.
 *   - 'roles': (optional) An associative array containing the roles allowed to
 *     access/use the text format.
 *   - 'filters': (optional) An associative, multi-dimensional array of filters
 *     assigned to the text format, using the properties:
 *     - 'weight': The weight of the filter in the text format.
 *     - 'status': A boolean indicating whether the filter is enabled in the
 *       text format.
 *     - 'module': The name of the module implementing the filter.
 *     - 'settings': (optional) An array of configured settings for the filter.
 *       See hook_filter_info() for details.
 */
function filter_format_save(&$format) {
  $format->name = trim($format->name);

  // Add a new text format.
  if (empty($format->format)) {
    $return = drupal_write_record('filter_format', $format);
  }
  else {
    $return = drupal_write_record('filter_format', $format, 'format');
  }

  // Get the filters currently active in the format, to add new filters
  // to the bottom.
  $current = filter_list_format($format->format, TRUE);
  $filter_info = filter_get_filters();
  if (!isset($format->filters)) {
    $format->filters = array();
  }
  foreach ($format->filters as $name => $filter) {
    $fields = array();
    // Add new filters to the bottom.
    $fields['weight'] = isset($current[$name]->weight) ? $current[$name]->weight : 10;
    $fields['status'] = $filter['status'];
    $fields['module'] = $filter_info[$name]['module'];
    $format->filters[$name]['module'] = $filter_info[$name]['module'];
    // Only update settings if there are any.
    if (!empty($filter['settings'])) {
      $fields['settings'] = serialize($filter['settings']);
    }
    db_merge('filter')
      ->key(array(
        'format' => $format->format,
        'name' => $name,
      ))
      ->fields($fields)
      ->execute();
  }

  if ($return == SAVED_NEW) {
    module_invoke_all('filter_format_insert', $format);
  }
  else {
    module_invoke_all('filter_format_update', $format);
    // Explicitly indicate that the format was updated. We need to do this
    // since if the filters were updated but the format object itself was not,
    // the call to drupal_write_record() above would not return an indication
    // that anything had changed.
    $return = SAVED_UPDATED;

    // Clear the filter cache whenever a text format is updated.
    cache_clear_all($format->format . ':', 'cache_filter', TRUE);
  }

  filter_formats_reset();

  return $return;
}

/**
 * Delete a text format.
 *
 * @param $format
 *   The text format object to be deleted.
 */
function filter_format_delete($format) {
  db_delete('filter_format')
    ->condition('format', $format->format)
    ->execute();
  db_delete('filter')
    ->condition('format', $format->format)
    ->execute();

  // Allow modules to react on text format deletion.
  $fallback = filter_format_load(filter_fallback_format());
  module_invoke_all('filter_format_delete', $format, $fallback);

  filter_formats_reset();
  cache_clear_all($format->format . ':', 'cache_filter', TRUE);
}

/**
 * Display a text format form title.
 */
function filter_admin_format_title($format) {
  return $format->name;
}

/**
 * Implement hook_permission().
 */
function filter_permission() {
  $perms['administer filters'] = array(
    'title' => t('Administer filters'),
    'description' => t('Manage text formats and filters, and use any of them, without restriction, when entering or editing content. %warning', array('%warning' => t('Warning: Give to trusted roles only; this permission has security implications.'))),
  );

  // Generate permissions for each text format. Warn the administrator that any
  // of them are potentially unsafe.
  foreach (filter_formats() as $format) {
    $permission = filter_permission_name($format);
    if (!empty($permission)) {
      // Only link to the text format configuration page if the user who is
      // viewing this will have access to that page.
      $format_name_replacement = user_access('administer filters') ? l($format->name, 'admin/config/content/formats/' . $format->format) : theme('placeholder', array('text' => $format->name));
      $perms[$permission] = array(
        'title' => t("Use the %text_format text format", array('%text_format' => $format->name)),
        'description' => t('Use !text_format in forms when entering or editing content. %warning', array('!text_format' => $format_name_replacement, '%warning' => t('Warning: This permission may have security implications depending on how the text format is configured.'))),
      );
    }
  }
  return $perms;
}

/**
 * Returns the machine-readable permission name for a provided text format.
 *
 * @param $format
 *   An object representing a text format.
 * @return
 *   The machine-readable permission name, or FALSE if the provided text format
 *   is malformed or is the fallback format (which is available to all users).
 */
function filter_permission_name($format) {
  if (isset($format->format) && $format->format != filter_fallback_format()) {
    return 'use text format ' . $format->format;
  }
  return FALSE;
}

/**
 * Implement hook_cron().
 *
 * Expire outdated filter cache entries
 */
function filter_cron() {
  cache_clear_all(NULL, 'cache_filter');
}

/**
 * Retrieve a list of text formats, ordered by weight.
 *
 * @param $account
 *   (optional) If provided, only those formats that are allowed for this user
 *   account will be returned. All formats will be returned otherwise.
 * @return
 *   An array of text format objects, keyed by the format ID and ordered by
 *   weight.
 *
 * @see filter_formats_reset()
 */
function filter_formats($account = NULL) {
  $formats = &drupal_static(__FUNCTION__, array());

  // Statically cache all existing formats upfront.
  if (!isset($formats['all'])) {
    $formats['all'] = db_select('filter_format', 'ff')
      ->addTag('translatable')
      ->fields('ff')
      ->orderBy('weight')
      ->execute()
      ->fetchAllAssoc('format');
  }

  // Build a list of user-specific formats.
  if (isset($account) && !isset($formats['user'][$account->uid])) {
    $formats['user'][$account->uid] = array();
    foreach ($formats['all'] as $format) {
      if (filter_access($format, $account)) {
        $formats['user'][$account->uid][$format->format] = $format;
      }
    }
  }

  return isset($account) ? $formats['user'][$account->uid] : $formats['all'];
}

/**
 * Resets the static cache of all text formats.
 *
 * @see filter_formats()
 */
function filter_formats_reset() {
  drupal_static_reset('filter_list_format');
  drupal_static_reset('filter_formats');
}

/**
 * Retrieves a list of roles that are allowed to use a given text format.
 *
 * @param $format
 *   An object representing the text format.
 * @return
 *   An array of role names, keyed by role ID.
 */
function filter_get_roles_by_format($format) {
  // Handle the fallback format upfront (all roles have access to this format).
  if ($format->format == filter_fallback_format()) {
    return user_roles();
  }
  // Do not list any roles if the permission does not exist.
  $permission = filter_permission_name($format);
  return !empty($permission) ? user_roles(FALSE, $permission) : array();
}

/**
 * Retrieves a list of text formats that are allowed for a given role.
 *
 * @param $rid
 *   The user role ID to retrieve text formats for.
 * @return
 *   An array of text format objects that are allowed for the role, keyed by
 *   the text format ID and ordered by weight.
 */
function filter_get_formats_by_role($rid) {
  $formats = array();
  foreach (filter_formats() as $format) {
    $roles = filter_get_roles_by_format($format);
    if (isset($roles[$rid])) {
      $formats[$format->format] = $format;
    }
  }
  return $formats;
}

/**
 * Returns the ID of the default text format for a particular user.
 *
 * The default text format is the first available format that the user is
 * allowed to access, when the formats are ordered by weight. It should
 * generally be used as a default choice when presenting the user with a list
 * of possible text formats (for example, in a node creation form).
 *
 * Conversely, when existing content that does not have an assigned text format
 * needs to be filtered for display, the default text format is the wrong
 * choice, because it is not guaranteed to be consistent from user to user, and
 * some trusted users may have an unsafe text format set by default, which
 * should not be used on text of unknown origin. Instead, the fallback format
 * returned by filter_fallback_format() should be used, since that is intended
 * to be a safe, consistent format that is always available to all users.
 *
 * @param $account
 *   (optional) The user account to check. Defaults to the currently logged-in
 *   user.
 * @return
 *   The ID of the user's default text format.
 *
 * @see filter_fallback_format()
 */
function filter_default_format($account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  // Get a list of formats for this user, ordered by weight. The first one
  // available is the user's default format.
  $format = array_shift(filter_formats($account));
  return $format->format;
}

/**
 * Returns the ID of the fallback text format that all users have access to.
 */
function filter_fallback_format() {
  // This variable is automatically set in the database for all installations
  // of Drupal. In the event that it gets deleted somehow, there is no safe
  // default to return, since we do not want to risk making an existing (and
  // potentially unsafe) text format on the site automatically available to all
  // users. Returning NULL at least guarantees that this cannot happen.
  return variable_get('filter_fallback_format');
}

/**
 * Returns the title of the fallback text format.
 */
function filter_fallback_format_title() {
  $fallback_format = filter_format_load(filter_fallback_format());
  return filter_admin_format_title($fallback_format);
}

/**
 * Return a list of all filters provided by modules.
 */
function filter_get_filters() {
  $filters = &drupal_static(__FUNCTION__, array());

  if (empty($filters)) {
    foreach (module_implements('filter_info') as $module) {
      $info = module_invoke($module, 'filter_info');
      if (isset($info) && is_array($info)) {
        // Assign the name of the module implementing the filters.
        foreach (array_keys($info) as $name) {
          $info[$name]['module'] = $module;
        }
        $filters = array_merge($filters, $info);
      }
    }
    // Allow modules to alter filter definitions.
    drupal_alter('filter_info', $filters);

    uasort($filters, '_filter_list_cmp');
  }

  return $filters;
}

/**
 * Helper function for sorting the filter list by filter name.
 */
function _filter_list_cmp($a, $b) {
  return strcmp($a['title'], $b['title']);
}

/**
 * Check if text in a certain text format is allowed to be cached.
 */
function filter_format_allowcache($format_id) {
  static $cache = array();
  if (!isset($cache[$format_id])) {
    $cache[$format_id] = db_query('SELECT cache FROM {filter_format} WHERE format = :format', array(':format' => $format_id))->fetchField();
  }
  return $cache[$format_id];
}

/**
 * Retrieve a list of filters for a given text format.
 *
 * @param $format_id
 *   The format ID.
 *
 * @return
 *   An array of filter objects assosiated to the given format.
 */
function filter_list_format($format_id) {
  $filters = &drupal_static(__FUNCTION__, array());
  $filter_info = filter_get_filters();

  if (!isset($filters[$format_id])) {
    $format_filters = array();
    $query = db_select('filter', 'filter')
      ->fields('filter')
      ->condition('format', $format_id)
      ->orderBy('weight')
      ->orderBy('module')
      ->orderBy('name');
    $result = $query->execute()->fetchAllAssoc('name');
    foreach ($result as $name => $filter) {
      if (isset($filter_info[$name])) {
        $filter->title = $filter_info[$name]['title'];
        // Unpack stored filter settings.
        $filter->settings = (isset($filter->settings) ? unserialize($filter->settings) : array());
        // Apply default filter settings.
        if (isset($filter_info[$name]['default settings'])) {
          $filter->settings = array_merge($filter_info[$name]['default settings'], $filter->settings);
        }
        $format_filters[$name] = $filter;
      }
    }
    $filters[$format_id] = $format_filters;
  }

  return isset($filters[$format_id]) ? $filters[$format_id] : array();
}

/**
 * Run all the enabled filters on a piece of text.
 *
 * Note: Because filters can inject JavaScript or execute PHP code, security is
 * vital here. When a user supplies a text format, you should validate it using
 * filter_access() before accepting/using it. This is normally done in the
 * validation stage of the Form API. You should for example never make a preview
 * of content in a disallowed format.
 *
 * @param $text
 *   The text to be filtered.
 * @param $format_id
 *   The format id of the text to be filtered. If no format is assigned, the
 *   fallback format will be used.
 * @param $langcode
 *   Optional: the language code of the text to be filtered, e.g. 'en' for
 *   English. This allows filters to be language aware so language specific
 *   text replacement can be implemented.
 * @param $cache
 *   Boolean whether to cache the filtered output in the {cache_filter} table.
 *   The caller may set this to FALSE when the output is already cached
 *   elsewhere to avoid duplicate cache lookups and storage.
 */
function check_markup($text, $format_id = NULL, $langcode = '', $cache = FALSE) {
  if (empty($format_id)) {
    $format_id = filter_fallback_format();
  }
  $format = filter_format_load($format_id);

  // Check for a cached version of this piece of text.
  $cache = $cache && filter_format_allowcache($format->format);
  $cache_id = '';
  if ($cache) {
    $cache_id = $format->format . ':' . $langcode . ':' . md5($text);
    if ($cached = cache_get($cache_id, 'cache_filter')) {
      return $cached->data;
    }
  }

  // Convert all Windows and Mac newlines to a single newline, so filters only
  // need to deal with one possibility.
  $text = str_replace(array("\r\n", "\r"), "\n", $text);

  // Get a complete list of filters, ordered properly.
  $filters = filter_list_format($format->format);
  $filter_info = filter_get_filters();

  // Give filters the chance to escape HTML-like data such as code or formulas.
  foreach ($filters as $name => $filter) {
    if ($filter->status && isset($filter_info[$name]['prepare callback']) && function_exists($filter_info[$name]['prepare callback'])) {
      $function = $filter_info[$name]['prepare callback'];
      $text = $function($text, $filter, $format, $langcode, $cache, $cache_id);
    }
  }

  // Perform filtering.
  foreach ($filters as $name => $filter) {
    if ($filter->status && isset($filter_info[$name]['process callback']) && function_exists($filter_info[$name]['process callback'])) {
      $function = $filter_info[$name]['process callback'];
      $text = $function($text, $filter, $format, $langcode, $cache, $cache_id);
    }
  }

  // Store in cache with a minimum expiration time of 1 day.
  if ($cache) {
    cache_set($cache_id, $text, 'cache_filter', REQUEST_TIME + (60 * 60 * 24));
  }

  return $text;
}

/**
 * Generates a selector for choosing a format in a form.
 *
 * @param $selected_format
 *   The ID of the format that is currently selected; uses the default format
 *   for the current user if not provided.
 * @param $weight
 *   The weight of the form element within the form.
 * @param $parents
 *   The parents array of the element. Required when defining multiple text
 *   formats on a single form or having a different parent than 'format'.
 *
 * @return
 *   Form API array for the form element.
 *
 * @ingroup forms
 */
function filter_form($selected_format = NULL, $weight = NULL, $parents = array('format')) {
  global $user;

  // Use the default format for this user if none was selected.
  if (empty($selected_format)) {
    $selected_format = filter_default_format($user);
  }

  // Get a list of formats that the current user has access to.
  $formats = filter_formats($user);

  drupal_add_js('misc/form.js');
  drupal_add_css(drupal_get_path('module', 'filter') . '/filter.css');
  $element_id = drupal_html_id('edit-' . implode('-', $parents));

  $form = array(
    '#type' => 'fieldset',
    '#weight' => $weight,
    '#attributes' => array('class' => array('filter-wrapper')),
  );
  $form['format_guidelines'] = array(
    '#prefix' => '<div id="' . $element_id . '-guidelines" class="filter-guidelines">',
    '#suffix' => '</div>',
    '#weight' => 2,
  );
  foreach ($formats as $format) {
    $options[$format->format] = $format->name;
    $form['format_guidelines'][$format->format] = array(
      '#markup' => theme('filter_guidelines', array('format' => $format)),
    );
  }
  $form['format'] = array(
    '#type' => 'select',
    '#title' => t('Text format'),
    '#options' => $options,
    '#default_value' => $selected_format,
    '#parents' => $parents,
    '#access' => count($formats) > 1,
    '#id' => $element_id,
    '#attributes' => array('class' => array('filter-list')),
  );
  $form['format_help'] = array(
    '#prefix' => '<div id="' . $element_id . '-help" class="filter-help">',
    '#markup' => theme('filter_tips_more_info'),
    '#suffix' => '</div>',
    '#weight' => 1,
  );

  return $form;
}

/**
 * Checks if a user has access to a particular text format.
 *
 * @param $format
 *   An object representing the text format.
 * @param $account
 *   (optional) The user account to check access for; if omitted, the currently
 *   logged-in user is used.
 *
 * @return
 *   Boolean TRUE if the user is allowed to access the given format.
 */
function filter_access($format, $account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  // Handle special cases up front. All users have access to the fallback
  // format, and administrators have access to all formats.
  if (user_access('administer filters', $account) || $format->format == filter_fallback_format()) {
    return TRUE;
  }
  // Check the permission if one exists; otherwise, we have a non-existent
  // format so we return FALSE.
  $permission = filter_permission_name($format);
  return !empty($permission) && user_access($permission, $account);
}

/**
 * Helper function for fetching filter tips.
 */
function _filter_tips($format_id, $long = FALSE) {
  global $user;

  $formats = filter_formats($user);
  $filter_info = filter_get_filters();

  $tips = array();

  // If only listing one format, extract it from the $formats array.
  if ($format_id != -1) {
    $formats = array($formats[$format_id]);
  }

  foreach ($formats as $format) {
    $filters = filter_list_format($format->format);
    $tips[$format->name] = array();
    foreach ($filters as $name => $filter) {
      if (isset($filter_info[$name]['tips callback']) && function_exists($filter_info[$name]['tips callback'])) {
        $tip = $filter_info[$name]['tips callback']($filter, $format, $long);
        $tips[$format->name][$name] = array('tip' => $tip, 'id' => $name);
      }
    }
  }

  return $tips;
}

/**
 * Parses an HTML snippet and returns it as a DOM object.
 *
 * This function loads the body part of a partial (X)HTML document
 * and returns a full DOMDocument object that represents this document.
 * You can use filter_dom_serialize() to serialize this DOMDocument
 * back to a XHTML snippet.
 *
 * @param $text
 *   The partial (X)HTML snippet to load. Invalid mark-up
 *   will be corrected on import.
 * @return
 *   A DOMDocument that represents the loaded (X)HTML snippet.
 */
function filter_dom_load($text) {
  // Ignore warnings during HTML soup loading.
  $dom_document = @DOMDocument::loadHTML('<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /></head><body>' . $text . '</body></html>');

  return $dom_document;
}

/**
 * Converts a DOM object back to an HTML snippet.
 *
 * The function serializes the body part of a DOMDocument
 * back to an XHTML snippet.
 *
 * The resulting XHTML snippet will be properly formatted
 * to be compatible with HTML user agents.
 *
 * @param $dom_document
 *   A DOMDocument object to serialize, only the tags below
 *   the first <body> node will be converted.
 * @return
 *   A valid (X)HTML snippet, as a string.
 */
function filter_dom_serialize($dom_document) {
  $body_node = $dom_document->getElementsByTagName('body')->item(0);
  $body_content = '';
  foreach ($body_node->childNodes as $child_node) {
    $body_content .= $dom_document->saveXML($child_node);
  }
  return preg_replace('|<([^>]*)/>|i', '<$1 />', $body_content);
}

/**
 * Format a link to the more extensive filter tips.
 *
 * @ingroup themeable
 */
function theme_filter_tips_more_info() {
  return '<p>' . l(t('More information about text formats'), 'filter/tips') . '</p>';
}

/**
 * Format guidelines for a text format.
 *
 * @param $variables
 *   An associative array containing:
 *   - format: An object representing a text format.
 *
 * @ingroup themeable
 */
function theme_filter_guidelines($variables) {
  $format = $variables['format'];

  $name = isset($format->name) ? '<label>' . $format->name . ':</label>' : '';
  return '<div id="filter-guidelines-' . $format->format . '" class="filter-guidelines-item">' . $name . theme('filter_tips', array('tips' => _filter_tips($format->format, FALSE))) . '</div>';
}

/**
 * @name Standard filters
 * @{
 * Filters implemented by the filter.module.
 */

/**
 * Implement hook_filter_info().
 */
function filter_filter_info() {
  $filters['filter_html'] = array(
    'title' => t('Limit allowed HTML tags'),
    'description' => t('Allows you to restrict the HTML tags the user can use. It will also remove harmful content such as JavaScript events, JavaScript URLs and CSS styles from those tags that are not removed.'),
    'process callback' => '_filter_html',
    'settings callback' => '_filter_html_settings',
    'default settings' => array(
      'allowed_html' => '<a> <em> <strong> <cite> <blockquote> <code> <ul> <ol> <li> <dl> <dt> <dd>',
      'filter_html_help' => 1,
      'filter_html_nofollow' => 0,
    ),
    'tips callback' => '_filter_html_tips',
  );
  $filters['filter_autop'] = array(
    'title' => t('Convert line breaks'),
    'description' => t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt;) tags.'),
    'process callback' => '_filter_autop',
    'tips callback' => '_filter_autop_tips',
  );
  $filters['filter_url'] = array(
    'title' => t('Convert URLs into links'),
    'description' => t('Turns web and e-mail addresses into clickable links.'),
    'process callback' => '_filter_url',
    'settings callback' => '_filter_url_settings',
    'default settings' => array(
      'filter_url_length' => 72,
    ),
    'tips callback' => '_filter_url_tips',
  );
  $filters['filter_htmlcorrector'] = array(
    'title' =>  t('Correct broken HTML'),
    'description' => t('Corrects faulty and chopped off HTML in postings.'),
    'process callback' => '_filter_htmlcorrector',
  );
  $filters['filter_html_escape'] = array(
    'title' => t('Escape all HTML'),
    'description' => t('Escapes all HTML tags, so they will be visible instead of being effective.'),
    'process callback' => '_filter_html_escape',
    'tips callback' => '_filter_html_escape_tips',
  );
  return $filters;
}

/**
 * Settings callback for the HTML filter.
 */
function _filter_html_settings($form, &$form_state, $filter, $defaults) {
  $form['allowed_html'] = array(
    '#type' => 'textfield',
    '#title' => t('Allowed HTML tags'),
    '#default_value' => isset($filter->settings['allowed_html']) ? $filter->settings['allowed_html'] : $defaults['allowed_html'],
    '#size' => 64,
    '#maxlength' => 1024,
    '#description' => t('Specify a list of tags which should not be stripped. (Note that JavaScript event attributes are always stripped.)'),
  );
  $form['filter_html_help'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display HTML help'),
    '#default_value' => isset($filter->settings['filter_html_help']) ? $filter->settings['filter_html_help'] : $defaults['filter_html_help'],
    '#description' => t('If enabled, Drupal will display some basic HTML help in the long filter tips.'),
  );
  $form['filter_html_nofollow'] = array(
    '#type' => 'checkbox',
    '#title' => t('Spam link deterrent'),
    '#default_value' => isset($filter->settings['filter_html_nofollow']) ? $filter->settings['filter_html_nofollow'] : $defaults['filter_html_nofollow'],
    '#description' => t('If enabled, Drupal will add rel="nofollow" to all links, as a measure to reduce the effectiveness of spam links. Note: this will also prevent valid links from being followed by search engines, therefore it is likely most effective when enabled for anonymous users.'),
  );
  return $form;
}

/**
 * HTML filter. Provides filtering of input into accepted HTML.
 */
function _filter_html($text, $filter) {
  $allowed_tags = preg_split('/\s+|<|>/', $filter->settings['allowed_html'], -1, PREG_SPLIT_NO_EMPTY);
  $text = filter_xss($text, $allowed_tags);

  if ($filter->settings['filter_html_nofollow']) {
    $html_dom = filter_dom_load($text);
    $links = $html_dom->getElementsByTagName('a');
    foreach($links as $link) {
      $link->setAttribute('rel', 'nofollow');
    }
    $text = filter_dom_serialize($html_dom);
  }

  return trim($text);
}

/**
 * Filter tips callback for HTML filter.
 */
function _filter_html_tips($filter, $format, $long = FALSE) {
  global $base_url;

  if (!($allowed_html = $filter->settings['allowed_html'])) {
    return;
  }
  $output = t('Allowed HTML tags: @tags', array('@tags' => $allowed_html));
  if (!$long) {
    return $output;
  }

  $output = '<p>' . $output . '</p>';
  if (!$filter->settings['filter_html_help']) {
    return $output;
  }

  $output .= '<p>' . t('This site allows HTML content. While learning all of HTML may feel intimidating, learning how to use a very small number of the most basic HTML "tags" is very easy. This table provides examples for each tag that is enabled on this site.') . '</p>';
  $output .= '<p>' . t('For more information see W3C\'s <a href="@html-specifications">HTML Specifications</a> or use your favorite search engine to find other sites that explain HTML.', array('@html-specifications' => 'http://www.w3.org/TR/html/')) . '</p>';
  $tips = array(
    'a' => array(t('Anchors are used to make links to other pages.'), '<a href="' . $base_url . '">' . variable_get('site_name', 'Drupal') . '</a>'),
    'br' => array(t('By default line break tags are automatically added, so use this tag to add additional ones. Use of this tag is different because it is not used with an open/close pair like all the others. Use the extra " /" inside the tag to maintain XHTML 1.0 compatibility'), t('Text with <br />line break')),
    'p' => array(t('By default paragraph tags are automatically added, so use this tag to add additional ones.'), '<p>' . t('Paragraph one.') . '</p> <p>' . t('Paragraph two.') . '</p>'),
    'strong' => array(t('Strong'), '<strong>' . t('Strong') . '</strong>'),
    'em' => array(t('Emphasized'), '<em>' . t('Emphasized') . '</em>'),
    'cite' => array(t('Cited'), '<cite>' . t('Cited') . '</cite>'),
    'code' => array(t('Coded text used to show programming source code'), '<code>' . t('Coded') . '</code>'),
    'b' => array(t('Bolded'), '<b>' . t('Bolded') . '</b>'),
    'u' => array(t('Underlined'), '<u>' . t('Underlined') . '</u>'),
    'i' => array(t('Italicized'), '<i>' . t('Italicized') . '</i>'),
    'sup' => array(t('Superscripted'), t('<sup>Super</sup>scripted')),
    'sub' => array(t('Subscripted'), t('<sub>Sub</sub>scripted')),
    'pre' => array(t('Preformatted'), '<pre>' . t('Preformatted') . '</pre>'),
    'abbr' => array(t('Abbreviation'), t('<abbr title="Abbreviation">Abbrev.</abbr>')),
    'acronym' => array(t('Acronym'), t('<acronym title="Three-Letter Acronym">TLA</acronym>')),
    'blockquote' => array(t('Block quoted'), '<blockquote>' . t('Block quoted') . '</blockquote>'),
    'q' => array(t('Quoted inline'), '<q>' . t('Quoted inline') . '</q>'),
    // Assumes and describes tr, td, th.
    'table' => array(t('Table'), '<table> <tr><th>' . t('Table header') . '</th></tr> <tr><td>' . t('Table cell') . '</td></tr> </table>'),
    'tr' => NULL, 'td' => NULL, 'th' => NULL,
    'del' => array(t('Deleted'), '<del>' . t('Deleted') . '</del>'),
    'ins' => array(t('Inserted'), '<ins>' . t('Inserted') . '</ins>'),
     // Assumes and describes li.
    'ol' => array(t('Ordered list - use the &lt;li&gt; to begin each list item'), '<ol> <li>' . t('First item') . '</li> <li>' . t('Second item') . '</li> </ol>'),
    'ul' => array(t('Unordered list - use the &lt;li&gt; to begin each list item'), '<ul> <li>' . t('First item') . '</li> <li>' . t('Second item') . '</li> </ul>'),
    'li' => NULL,
    // Assumes and describes dt and dd.
    'dl' => array(t('Definition lists are similar to other HTML lists. &lt;dl&gt; begins the definition list, &lt;dt&gt; begins the definition term and &lt;dd&gt; begins the definition description.'), '<dl> <dt>' . t('First term') . '</dt> <dd>' . t('First definition') . '</dd> <dt>' . t('Second term') . '</dt> <dd>' . t('Second definition') . '</dd> </dl>'),
    'dt' => NULL, 'dd' => NULL,
    'h1' => array(t('Heading'), '<h1>' . t('Title') . '</h1>'),
    'h2' => array(t('Heading'), '<h2>' . t('Subtitle') . '</h2>'),
    'h3' => array(t('Heading'), '<h3>' . t('Subtitle three') . '</h3>'),
    'h4' => array(t('Heading'), '<h4>' . t('Subtitle four') . '</h4>'),
    'h5' => array(t('Heading'), '<h5>' . t('Subtitle five') . '</h5>'),
    'h6' => array(t('Heading'), '<h6>' . t('Subtitle six') . '</h6>')
  );
  $header = array(t('Tag Description'), t('You Type'), t('You Get'));
  preg_match_all('/<([a-z0-9]+)[^a-z0-9]/i', $allowed_html, $out);
  foreach ($out[1] as $tag) {
    if (array_key_exists($tag, $tips)) {
      if ($tips[$tag]) {
        $rows[] = array(
          array('data' => $tips[$tag][0], 'class' => array('description')),
          array('data' => '<code>' . check_plain($tips[$tag][1]) . '</code>', 'class' => array('type')),
          array('data' => $tips[$tag][1], 'class' => array('get'))
        );
      }
    }
    else {
      $rows[] = array(
        array('data' => t('No help provided for tag %tag.', array('%tag' => $tag)), 'class' => array('description'), 'colspan' => 3),
      );
    }
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));

  $output .= '<p>' . t('Most unusual characters can be directly entered without any problems.') . '</p>';
  $output .= '<p>' . t('If you do encounter problems, try using HTML character entities. A common example looks like &amp;amp; for an ampersand &amp; character. For a full list of entities see HTML\'s <a href="@html-entities">entities</a> page. Some of the available characters include:', array('@html-entities' => 'http://www.w3.org/TR/html4/sgml/entities.html')) . '</p>';

  $entities = array(
    array(t('Ampersand'), '&amp;'),
    array(t('Greater than'), '&gt;'),
    array(t('Less than'), '&lt;'),
    array(t('Quotation mark'), '&quot;'),
  );
  $header = array(t('Character Description'), t('You Type'), t('You Get'));
  unset($rows);
  foreach ($entities as $entity) {
    $rows[] = array(
      array('data' => $entity[0], 'class' => array('description')),
      array('data' => '<code>' . check_plain($entity[1]) . '</code>', 'class' => array('type')),
      array('data' => $entity[1], 'class' => array('get'))
    );
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));
  return $output;
}

/**
 * Settings callback for URL filter.
 */
function _filter_url_settings($form, &$form_state, $filter, $defaults) {
  $form['filter_url_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum link text length'),
    '#default_value' => isset($filter->settings['filter_url_length']) ? $filter->settings['filter_url_length'] : $defaults['filter_url_length'],
    '#maxlength' => 4,
    '#description' => t('URLs longer than this number of characters will be truncated to prevent long strings that break formatting. The link itself will be retained; just the text portion of the link will be truncated.'),
  );
  return $form;
}

/**
 * URL filter. Automatically converts text web addresses (URLs, e-mail addresses,
 * ftp links, etc.) into hyperlinks.
 */
function _filter_url($text, $filter) {
  // Pass length to regexp callback
  _filter_url_trim(NULL, $filter->settings['filter_url_length']);

  $text = ' ' . $text . ' ';

  // Match absolute URLs.
  $text = preg_replace_callback("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])((http://|https://|ftp://|mailto:|smb://|afp://|file://|gopher://|news://|ssl://|sslv2://|sslv3://|tls://|tcp://|udp://)([a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+*~#&=/;-]))([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_full_links', $text);

  // Match e-mail addresses.
  $text = preg_replace("`(<p>|<li>|<br\s*/?>|[ \n\r\t\(])([A-Za-z0-9._-]+@[A-Za-z0-9._+-]+\.[A-Za-z]{2,4})([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '\1<a href="mailto:\2">\2</a>\3', $text);

  // Match www domains/addresses.
  $text = preg_replace_callback("`(<p>|<li>|[ \n\r\t\(])(www\.[a-zA-Z0-9@:%_+*~#?&=.,/;-]*[a-zA-Z0-9@:%_+~#\&=/;-])([.,?!]*?)(?=(</p>|</li>|<br\s*/?>|[ \n\r\t\)]))`i", '_filter_url_parse_partial_links', $text);
  $text = substr($text, 1, -1);

  return $text;
}

/**
 * Make links out of absolute URLs.
 */
function _filter_url_parse_full_links($match) {
  $match[2] = decode_entities($match[2]);
  $caption = check_plain(_filter_url_trim($match[2]));
  $match[2] = check_url($match[2]);
  return $match[1] . '<a href="' . $match[2] . '" title="' . $match[2] . '">' . $caption . '</a>' . $match[5];
}

/**
 * Make links out of domain names starting with "www."
 */
function _filter_url_parse_partial_links($match) {
  $match[2] = decode_entities($match[2]);
  $caption = check_plain(_filter_url_trim($match[2]));
  $match[2] = check_plain($match[2]);
  return $match[1] . '<a href="http://' . $match[2] . '" title="' . $match[2] . '">' . $caption . '</a>' . $match[3];
}

/**
 * Shortens long URLs to http://www.example.com/long/url...
 */
function _filter_url_trim($text, $length = NULL) {
  static $_length;
  if ($length !== NULL) {
    $_length = $length;
  }

  // Use +3 for '...' string length.
  if (strlen($text) > $_length + 3) {
    $text = substr($text, 0, $_length) . '...';
  }

  return $text;
}

/**
 * Filter tips callback for URL filter.
 */
function _filter_url_tips($filter, $format, $long = FALSE) {
  return t('Web page addresses and e-mail addresses turn into links automatically.');
}

/**
 * Scan input and make sure that all HTML tags are properly closed and nested.
 */
function _filter_htmlcorrector($text) {
  return filter_dom_serialize(filter_dom_load($text));
}

/**
 * Convert line breaks into <p> and <br> in an intelligent fashion.
 * Based on: http://photomatt.net/scripts/autop
 */
function _filter_autop($text) {
  // All block level tags
  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6]|hr)';

  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.
  // We don't apply any processing to the contents of these tags to avoid messing
  // up code. We look for matched pairs and allow basic nesting. For example:
  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"
  $chunks = preg_split('@(</?(?:pre|script|style|object)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and literals
  // and begins and ends with a literal (inserting NULL as required).
  $ignore = FALSE;
  $ignoretag = '';
  $output = '';
  foreach ($chunks as $i => $chunk) {
    if ($i % 2) {
      // Opening or closing tag?
      $open = ($chunk[1] != '/');
      list($tag) = preg_split('/[ >]/', substr($chunk, 2 - $open), 2);
      if (!$ignore) {
        if ($open) {
          $ignore = TRUE;
          $ignoretag = $tag;
        }
      }
      // Only allow a matching tag to close it.
      elseif (!$open && $ignoretag == $tag) {
        $ignore = FALSE;
        $ignoretag = '';
      }
    }
    elseif (!$ignore) {
      $chunk = preg_replace('|\n*$|', '', $chunk) . "\n\n"; // just to make things a little easier, pad the end
      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);
      $chunk = preg_replace('!(<' . $block . '[^>]*>)!', "\n$1", $chunk); // Space things out a little
      $chunk = preg_replace('!(</' . $block . '>)!', "$1\n\n", $chunk); // Space things out a little
      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates
      $chunk = preg_replace('/^\n|\n\s*\n$/', '', $chunk);
      $chunk = '<p>' . preg_replace('/\n\s*\n\n?(.)/', "</p>\n<p>$1", $chunk) . "</p>\n"; // make paragraphs, including one at the end
      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists
      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);
      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);
      $chunk = preg_replace('|<p>\s*</p>\n?|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace
      $chunk = preg_replace('!<p>\s*(</?' . $block . '[^>]*>)!', "$1", $chunk);
      $chunk = preg_replace('!(</?' . $block . '[^>]*>)\s*</p>!', "$1", $chunk);
      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks
      $chunk = preg_replace('!(</?' . $block . '[^>]*>)\s*<br />!', "$1", $chunk);
      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);
      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);
    }
    $output .= $chunk;
  }
  return $output;
}

/**
 * Filter tips callback for auto-paragraph filter.
 */
function _filter_autop_tips($filter, $format, $long = FALSE) {
  if ($long) {
    return t('Lines and paragraphs are automatically recognized. The &lt;br /&gt; line break, &lt;p&gt; paragraph and &lt;/p&gt; close paragraph tags are inserted automatically. If paragraphs are not recognized simply add a couple blank lines.');
  }
  else {
    return t('Lines and paragraphs break automatically.');
  }
}

/**
 * Escapes all HTML tags, so they will be visible instead of being effective.
 */
function _filter_html_escape($text) {
  return trim(check_plain($text));
}

/**
 * Filter tips callback for HTML escaping filter.
 */
function _filter_html_escape_tips($filter, $format, $long = FALSE) {
  return t('No HTML tags allowed.');
}

/**
 * @} End of "Standard filters".
 */
