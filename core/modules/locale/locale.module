<?php

/**
 * @file
 * Enables the translation of the user interface to languages other than English.
 *
 * When enabled, multiple languages can be added. The site interface can be
 * displayed in different languages, and nodes can have languages assigned. The
 * setup of languages and translations is completely web based. Gettext portable
 * object files are supported.
 */

use Drupal\Component\Serialization\Json;
use Drupal\Component\Utility\UrlHelper;
use Drupal\Component\Utility\Xss;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Language\Language;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\StringTranslation\TranslationWrapper;
use Drupal\Core\Language\LanguageInterface;
use Drupal\language\Entity\Language as LanguageEntity;
use Drupal\Component\Utility\Crypt;

/**
 * Regular expression pattern used to localize JavaScript strings.
 */
const LOCALE_JS_STRING = '(?:(?:\'(?:\\\\\'|[^\'])*\'|"(?:\\\\"|[^"])*")(?:\s*\+\s*)?)+';

/**
 * Regular expression pattern used to match simple JS object literal.
 *
 * This pattern matches a basic JS object, but will fail on an object with
 * nested objects. Used in JS file parsing for string arg processing.
 */
const LOCALE_JS_OBJECT = '\{.*?\}';

/**
 * Regular expression to match an object containing a key 'context'.
 *
 * Pattern to match a JS object containing a 'context key' with a string value,
 * which is captured. Will fail if there are nested objects.
 */
define('LOCALE_JS_OBJECT_CONTEXT', '
  \{              # match object literal start
  .*?             # match anything, non-greedy
  (?:             # match a form of "context"
    \'context\'
    |
    "context"
    |
    context
  )
  \s*:\s*         # match key-value separator ":"
  (' . LOCALE_JS_STRING . ')  # match context string
  .*?             # match anything, non-greedy
  \}              # match end of object literal
');

/**
 * Flag for locally not customized interface translation.
 *
 * Such translations are imported from .po files downloaded from
 * localize.drupal.org for example.
 */
const LOCALE_NOT_CUSTOMIZED = 0;

/**
 * Flag for locally customized interface translation.
 *
 * Such translations are edited from their imported originals on the user
 * interface or are imported as customized.
 */
const LOCALE_CUSTOMIZED = 1;

/**
 * Translation update mode: Use local files only.
 *
 * When checking for available translation updates, only local files will be
 * used. Any remote translation file will be ignored. Also custom modules and
 * themes which have set a "server pattern" to use a remote translation server
 * will be ignored.
 */
const LOCALE_TRANSLATION_USE_SOURCE_LOCAL = 'local';

/**
 * Translation update mode: Use both remote and local files.
 *
 * When checking for available translation updates, both local and remote files
 * will be checked.
 */
const LOCALE_TRANSLATION_USE_SOURCE_REMOTE_AND_LOCAL = 'remote_and_local';

/**
 * Default location of gettext file on the translation server.
 *
 * @see locale_translation_default_translation_server().
 */
const LOCALE_TRANSLATION_DEFAULT_SERVER_PATTERN = 'http://ftp.drupal.org/files/translations/%core/%project/%project-%version.%language.po';

/**
 * The number of seconds that the translations status entry should be considered.
 */
const LOCALE_TRANSLATION_STATUS_TTL = 600;

/**
 * UI option for override of existing translations. Override any translation.
 */
const LOCALE_TRANSLATION_OVERWRITE_ALL = 'all';

/**
 * UI option for override of existing translations. Only override non-customized
 * translations.
 */
const LOCALE_TRANSLATION_OVERWRITE_NON_CUSTOMIZED = 'non_customized';

/**
 * UI option for override of existing translations. Don't override existing
 * translations.
 */
const LOCALE_TRANSLATION_OVERWRITE_NONE = 'none';

/**
 * Translation source is a remote file.
 */
const LOCALE_TRANSLATION_REMOTE = 'remote';

/**
 * Translation source is a local file.
 */
const LOCALE_TRANSLATION_LOCAL = 'local';

/**
 * Translation source is the current translation.
 */
const LOCALE_TRANSLATION_CURRENT = 'current';

/**
 * Implements hook_help().
 */
function locale_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.locale':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Interface Translation module allows you to translate interface text (<em>strings</em>) into different languages, and to switch between them for the display of interface text. It uses the functionality provided by the <a href="!language">Language module</a>. For more information, see the <a href="!doc-url">online documentation for the Interface Translation module</a>.', array('!doc-url' => 'https://drupal.org/documentation/modules/locale/', '!language' => \Drupal::url('help.page', array('name' => 'language')))) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Importing translation files') . '</dt>';
      $output .= '<dd>' . t('Translation files with translated interface text are imported automatically when languages are added on the <a href="!languages">Languages</a> page, or when modules or themes are enabled. On the <a href="!locale-settings">Settings</a> page, the <em>Translation source</em> can be restricted to local files only, or to include the <a href="!server">Drupal translation server</a>. Although modules and themes may not be fully translated in all languages, new translations become available frequently. You can specify whether and how often to check for translation file updates and whether to overwrite existing translations on the <a href="!locale-settings">Settings</a> page. You can also manually import a translation file on the <a title="User interface translation import" href="!import">Import</a> page.', array('!import' => \Drupal::url('locale.translate_import'), '!locale-settings' => \Drupal::url('locale.settings'), '!languages' => \Drupal::url('language.admin_overview'), '!server' => 'https://localize.drupal.org')) . '</dd>';
      $output .= '<dt>' . t('Checking the translation status') . '</dt>';
      $output .= '<dd>' . t('You can check how much of the interface on your site is translated into which language on the <a href="!languages">Languages</a> page. On the <a href="!translation-updates">Available translation updates</a> page, you can check whether interface translation updates are available on the <a href="!server">Drupal translation server</a>.', array('!languages' => \Drupal::url('language.admin_overview'), '!translation-updates' => \Drupal::url('locale.translate_status'), '!server' => 'https://localize.drupal.org')) . '<dd>';
      $output .= '<dt>' . t('Translating individual strings') . '</dt>';
      $output .= '<dd>' . t('You can translate individual strings directly on the <a href="!translate">User interface translation</a> page, or download the currently-used translation file for a specific language on the <a title="User interface translation export" href="!export">Export</a> page. Once you have edited the translation file, you can then import it again on the <a title="User interface translation import" href="!import">Import</a> page.', array('!translate' => \Drupal::url('locale.translate_page'), '!export' => \Drupal::url('locale.translate_export'), '!import' => \Drupal::url('locale.translate_import'))) . '</dd>';
      $output .= '</dl>';
      return $output;

    case 'language.admin_overview':
      return '<p>' . t('Interface translations are automatically imported when a language is added, or when new modules or themes are enabled. The report <a href="!update">Available translation updates</a> shows the status. Interface text can be customized in the <a href="!translate">user interface translation</a> page.', array('!update' => \Drupal::url('locale.translate_status'), '!translate' => \Drupal::url('locale.translate_page'))) . '</p>';

    case 'locale.translate_page':
      $output = '<p>' . t('This page allows a translator to search for specific translated and untranslated strings, and is used when creating or editing translations. (Note: Because translation tasks involve many strings, it may be more convenient to <a title="User interface translation export" href="!export">export</a> strings for offline editing in a desktop Gettext translation editor.) Searches may be limited to strings in a specific language.', array('!export' => \Drupal::url('locale.translate_export'))) . '</p>';
      return $output;

    case 'locale.translate_import':
      $output = '<p>' . t('Translation files are automatically downloaded and imported when <a title="Languages" href="!language">languages</a> are added, or when modules or themes are enabled.', array('!language' => \Drupal::url('language.admin_overview'))) . '</p>';
      $output .= '<p>' . t('This page allows translators to manually import translated strings contained in a Gettext Portable Object (.po) file. Manual import may be used for customized translations or for the translation of custom modules and themes. To customize translations you can download a translation file from the <a href="!url">Drupal translation server</a> or <a title="User interface translation export" href="!export">export</a> translations from the site, customize the translations using a Gettext translation editor, and import the result using this page.', array('!url' => 'https://localize.drupal.org', '!export' => \Drupal::url('locale.translate_export'))) . '</p>';
      $output .= '<p>' . t('Note that importing large .po files may take several minutes.') . '</p>';
      return $output;

    case 'locale.translate_export':
      return '<p>' . t('This page exports the translated strings used by your site. An export file may be in Gettext Portable Object (<em>.po</em>) form, which includes both the original string and the translation (used to share translations with others), or in Gettext Portable Object Template (<em>.pot</em>) form, which includes the original strings only (used to create new translations with a Gettext translation editor).') . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function locale_permission() {
  return array(
    'translate interface' => array(
      'title' => t('Translate interface texts'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_theme().
 */
function locale_theme() {
  return array(
    'locale_translate_edit_form_strings' => array(
      'render element' => 'form',
      'file' => 'locale.pages.inc',
    ),
    'locale_translation_last_check' => array(
      'variables' => array('last' => NULL),
      'file' => 'locale.pages.inc',
      'template' => 'locale-translation-last-check',
    ),
    'locale_translation_update_info' => array(
      'variables' => array('updates' => array(), 'not_found' => array()),
      'file' => 'locale.pages.inc',
      'template' => 'locale-translation-update-info',
    ),
  );
}

/**
 * Implements hook_stream_wrappers().
 */
function locale_stream_wrappers() {
  $wrappers = array(
    'translations' => array(
      'name' => new TranslationWrapper('Translation files'),
      'class' => 'Drupal\locale\TranslationsStream',
      'description' => new TranslationWrapper('Translation files'),
      'type' => STREAM_WRAPPERS_LOCAL_HIDDEN,
    ),
  );
  return $wrappers;
}

/**
 * Implements hook_ENTITY_TYPE_insert() for 'language_entity'.
 */
function locale_language_entity_insert(LanguageEntity $language) {
  // @todo move these two cache clears out. See http://drupal.org/node/1293252
  // Changing the language settings impacts the interface: clear render cache.
  \Drupal::cache('render')->deleteAll();
  // Force JavaScript translation file re-creation for the new language.
  _locale_invalidate_js($language->id());
}

/**
 * Implements hook_ENTITY_TYPE_update() for 'language_entity'.
 */
function locale_language_entity_update(LanguageEntity $language) {
  // @todo move these two cache clears out. See http://drupal.org/node/1293252
  // Changing the language settings impacts the interface: clear render cache.
  \Drupal::cache('render')->deleteAll();
  // Force JavaScript translation file re-creation for the modified language.
  _locale_invalidate_js($language->id());
}

/**
 * Implements hook_ENTITY_TYPE_delete() for 'language_entity'.
 */
function locale_language_entity_delete(LanguageEntity $language) {
  // Remove translations.
  \Drupal::service('locale.storage')->deleteTranslations(array('language' => $language->id()));

  // Remove interface translation files.
  module_load_include('inc', 'locale', 'locale.bulk');
  locale_translate_delete_translation_files(array(), array($language->id()));

  // Remove translated configuration objects.
  \Drupal\locale\Locale::config()->deleteLanguageTranslations($language->id());

  // Changing the language settings impacts the interface:
  _locale_invalidate_js($language->id());
  \Drupal::cache('render')->deleteAll();

  // Clear locale translation caches.
  locale_translation_status_delete_languages(array($language->id()));
  \Drupal::cache()->delete('locale:' . $language->id());
}

/**
 * Returns list of translatable languages.
 *
 * @return array
 *   Array of installed languages keyed by language name. English is omitted
 *   unless it is marked as translatable.
 */
function locale_translatable_language_list() {
  $languages = \Drupal::languageManager()->getLanguages();
  if (!locale_translate_english()) {
    unset($languages['en']);
  }
  return $languages;
}

/**
 * Returns plural form index for a specific number.
 *
 * The index is computed from the formula of this language.
 *
 * @param $count
 *   Number to return plural for.
 * @param $langcode
 *   Optional language code to translate to a language other than
 *   what is used to display the page.
 *
 * @return
 *   The numeric index of the plural variant to use for this $langcode and
 *   $count combination or -1 if the language was not found or does not have a
 *   plural formula.
 */
function locale_get_plural($count, $langcode = NULL) {
  $language_interface = \Drupal::languageManager()->getCurrentLanguage();

  // Used to locally cache the plural formulas for all languages.
  $plural_formulas = &drupal_static(__FUNCTION__, array());
  // Used to store precomputed plural indexes corresponding to numbers
  // individually for each language.
  $plural_indexes = &drupal_static(__FUNCTION__ . ':plurals', array());

  $langcode = $langcode ? $langcode : $language_interface->id;

  if (!isset($plural_indexes[$langcode][$count])) {
    // Retrieve and statically cache the plural formulas for all languages.
    if (empty($plural_formulas)) {
      $plural_formulas = \Drupal::state()->get('locale.translation.plurals') ?: array();
    }
    // If there is a plural formula for the language, evaluate it for the given
    // $count and statically cache the result for the combination of language
    // and count, since the result will always be identical.
    if (!empty($plural_formulas[$langcode])) {
      // Plural formulas are stored as an array for 0-199. 100 is the highest
      // modulo used but storing 0-99 is not enough because below 100 we often
      // find exceptions (1, 2, etc).
      $index = $count > 199 ? 100 + ($count % 100) : $count;
      $plural_indexes[$langcode][$count] = isset($plural_formulas[$langcode]['formula'][$index]) ? $plural_formulas[$langcode]['formula'][$index] : $plural_formulas[$langcode]['formula']['default'];
    }
    // In case there is no plural formula for English (no imported translation
    // for English), use a default formula.
    elseif ($langcode == 'en') {
      $plural_indexes[$langcode][$count] = (int) ($count != 1);
    }
    // Otherwise, return -1 (unknown).
    else {
      $plural_indexes[$langcode][$count] = -1;
    }
  }
  return $plural_indexes[$langcode][$count];
}


/**
 * Implements hook_modules_installed().
 */
function locale_modules_installed($modules) {
  $components['module'] = $modules;
  locale_system_update($components);
}

/**
 * Implements hook_modules_uninstalled().
 */
function locale_modules_uninstalled($modules) {
  $components['module'] = $modules;
  locale_system_remove($components);
}

/**
 * Implements hook_themes_enabled().
 *
 * @todo This is technically wrong. We must not import upon enabling, but upon
 *   initial installation. The theme system is missing an installation hook.
 */
function locale_themes_enabled($themes) {
  $components['theme'] = $themes;
  locale_system_update($components);
}

/**
 * Implements hook_themes_disabled().
 */
function locale_themes_disabled($themes) {
  $components['theme'] = $themes;
  locale_system_remove($components);
}

/**
 * Implements hook_cron().
 *
 * @see locale_queue_info()
 */
function locale_cron() {
  // Update translations only when an update frequency was set by the admin
  // and a translatable language was set.
  // Update tasks are added to the queue here but processed by Drupal's cron
  // using the cron worker defined in locale_queue_info().
  if ($frequency = \Drupal::config('locale.settings')->get('translation.update_interval_days') && locale_translatable_language_list()) {
    module_load_include('translation.inc', 'locale');
    locale_cron_fill_queue();
  }
}

/**
 * Implements hook_queue_info().
 */
function locale_queue_info() {
  $queues['locale_translation'] = array(
    'title' => t('Update translations'),
    'worker callback' => 'locale_translation_worker',
    'cron' => array(
      'time' => 30,
    ),
  );
  return $queues;
}

/**
 * Callback: Executes interface translation queue tasks.
 *
 * The translation update functions executed here are batch operations which
 * are also used in translation update batches. The batch functions may need to
 * be executed multiple times to complete their task, typically this is the
 * translation import function. When a batch function is not finished, a new
 * queue task is created and added to the end of the queue. The batch context
 * data is needed to continue the batch task is stored in the queue with the
 * queue data.
 *
 * @param array $data
 *   Queue data array containing:
 *   - Function name.
 *   - Array of function arguments. Optionally contains the batch context data.
 *
 * @see locale_queue_info()
 */
function locale_translation_worker($data) {
  module_load_include('batch.inc', 'locale');
  list($function, $args) = $data;

  // We execute batch operation functions here to check, download and import the
  // translation files. Batch functions use a context variable as last argument
  // which is passed by reference. When a batch operation is called for the
  // first time a default batch context is created. When called iterative
  // (usually the batch import function) the batch context is passed through via
  // the queue and is part of the $data.
  $last = count($args) - 1;
  if (!is_array($args[$last]) || !isset($args[$last]['finished'])) {
    $batch_context = array(
      'sandbox'  => array(),
      'results'  => array(),
      'finished' => 1,
      'message'  => '',
    );
  }
  else {
    $batch_context = $args[$last];
    unset ($args[$last]);
  }
  $args = array_merge($args, array(&$batch_context));

  // Call the batch operation function.
  call_user_func_array($function, $args);

  // If the batch operation is not finished we create a new queue task to
  // continue the task. This is typically the translation import task.
  if ($batch_context['finished'] < 1) {
    unset($batch_context['strings']);
    $queue = \Drupal::queue('locale_translation', TRUE);
    $queue->createItem(array($function, $args));
  }
}

/**
 * Imports translations when new modules or themes are installed.
 *
 * This function will start a batch to import translations for the added
 * components.
 *
 * @param array $components
 *   An array of arrays of component (theme and/or module) names to import
 *   translations for, indexed by type.
 */
function locale_system_update(array $components) {
  $components += array('module' => array(), 'theme' => array());
  $list = array_merge($components['module'], $components['theme']);

  // Skip running the translation imports if in the installer,
  // because it would break out of the installer flow. We have
  // built-in support for translation imports in the installer.
  if (!drupal_installation_attempted() && locale_translatable_language_list() && \Drupal::config('locale.settings')->get('translation.import_enabled')) {
    module_load_include('compare.inc', 'locale');

    // Update the list of translatable projects and start the import batch.
    // Only when new projects are added the update batch will be triggered. Not
    // each enabled module will introduce a new project. E.g. sub modules.
    $projects = array_keys(locale_translation_build_projects());
    if ($list = array_intersect($list, $projects)) {
      module_load_include('fetch.inc', 'locale');
      // Get translation status of the projects, download and update
      // translations.
      $options = _locale_translation_default_update_options();
      $batch = locale_translation_batch_update_build($list, array(), $options);
      batch_set($batch);
    }
    \Drupal::moduleHandler()->loadInclude('locale', 'bulk.inc');
    if ($batch = locale_config_batch_update_components(array(), array(), $components)) {
      batch_set($batch);
    }
  }
}

/**
 * Delete translation history of modules and themes.
 *
 * Only the translation history is removed, not the source strings or
 * translations. This is not possible because strings are shared between
 * modules and we have no record of which string is used by which module.
 *
 * @param array $components
 *   An array of arrays of component (theme and/or module) names to import
 *   translations for, indexed by type.
 */
function locale_system_remove($components) {
  $components += array('module' => array(), 'theme' => array());
  $list = array_merge($components['module'], $components['theme']);
  if ($language_list = locale_translatable_language_list()) {
    module_load_include('compare.inc', 'locale');
    \Drupal::moduleHandler()->loadInclude('locale', 'bulk.inc');
    // Delete configuration translations.
    \Drupal\locale\Locale::config()->deleteComponentTranslations($components, array_keys($language_list));

    // Only when projects are removed, the translation files and records will be
    // deleted. Not each disabled module will remove a project, e.g., sub
    // modules.
    $projects = array_keys(locale_translation_get_projects());
    if ($list = array_intersect($list, $projects)) {
      locale_translation_file_history_delete($list);

      // Remove translation files.
      locale_translate_delete_translation_files($list, array());

      // Remove translatable projects.
      // Followup issue http://drupal.org/node/1842362 to replace the
      // {locale_project} table. Then change this to a function call.
      db_delete('locale_project')
        ->condition('name', $list)
        ->execute();

      // Clear the translation status.
      locale_translation_status_delete_projects($list);
    }

  }
}

/**
 * Implements hook_js_alter().
 */
function locale_js_alter(&$javascript) {
  $files = array();
  foreach ($javascript as $item) {
    if (isset($item['type']) && $item['type'] == 'file') {
      $files[] = $item['data'];
    }
  }
  if ($translation_file = locale_js_translate($files)) {
    $javascript[$translation_file] = drupal_js_defaults($translation_file);
  }
}

/**
 * Returns a list of translation files given a list of JavaScript files.
 *
 * This function checks all JavaScript files passed and invokes parsing if they
 * have not yet been parsed for Drupal.t() and Drupal.formatPlural() calls.
 * Also refreshes the JavaScript translation files if necessary, and returns
 * the filepath to the translation file (if any).
 *
 * @param array $files
 *   An array of local file paths.
 *
 * @return string|null
 *   The filepath to the translation file or NULL if no translation is
 *   applicable.
 */
function locale_js_translate(array $files = array()) {
  $language_interface = \Drupal::languageManager()->getCurrentLanguage();

  $dir = 'public://' . \Drupal::config('locale.settings')->get('javascript.directory');
  $parsed = \Drupal::state()->get('system.javascript_parsed') ?: array();
  $new_files = FALSE;

  foreach ($files as $filepath) {
    if (!in_array($filepath, $parsed)) {
      // Don't parse our own translations files.
      if (substr($filepath, 0, strlen($dir)) != $dir) {
        _locale_parse_js_file($filepath);
        $parsed[] = $filepath;
        $new_files = TRUE;
      }
    }
  }

  // If there are any new source files we parsed, invalidate existing
  // JavaScript translation files for all languages, adding the refresh
  // flags into the existing array.
  if ($new_files) {
    $parsed += _locale_invalidate_js();
  }

  // If necessary, rebuild the translation file for the current language.
  if (!empty($parsed['refresh:' . $language_interface->id])) {
    // Don't clear the refresh flag on failure, so that another try will
    // be performed later.
    if (_locale_rebuild_js()) {
      unset($parsed['refresh:' . $language_interface->id]);
    }
    // Store any changes after refresh was attempted.
    \Drupal::state()->set('system.javascript_parsed', $parsed);
  }
  // If no refresh was attempted, but we have new source files, we need
  // to store them too. This occurs if current page is in English.
  elseif ($new_files) {
    \Drupal::state()->set('system.javascript_parsed', $parsed);
  }

  // Add the translation JavaScript file to the page.
  $locale_javascripts = \Drupal::state()->get('locale.translation.javascript') ?: array();
  $translation_file = NULL;
  if (!empty($files) && !empty($locale_javascripts[$language_interface->id])) {
    // Add the translation JavaScript file to the page.
    $translation_file = $dir . '/' . $language_interface->id . '_' . $locale_javascripts[$language_interface->id] . '.js';
  }
  return $translation_file;
}

/**
 * Implements hook_library_alter().
 *
 * Provides the language support for the jQuery UI Date Picker.
 */
function locale_library_alter(array &$library, $name) {
  if ($name == 'core/jquery.ui.datepicker') {
    // locale.datepicker.js should be added in the JS_LIBRARY group, so that
    // the behavior executes early. JS_LIBRARY is the default.
    $library['dependencies'][] = 'locale/drupal.locale.datepicker';

    $language_interface = \Drupal::languageManager()->getCurrentLanguage();
    $settings['jquery']['ui']['datepicker'] = array(
      'isRTL' => $language_interface->direction == LanguageInterface::DIRECTION_RTL,
      'firstDay' => \Drupal::config('system.date')->get('first_day'),
    );
    $library['js'][] = array(
      'type' => 'setting',
      'data' => $settings,
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for language_admin_overview_form().
 */
function locale_form_language_admin_overview_form_alter(&$form, FormStateInterface $form_state) {
  $languages = $form['languages']['#languages'];

  $total_strings = \Drupal::service('locale.storage')->countStrings();
  $stats = array_fill_keys(array_keys($languages), array());

  // If we have source strings, count translations and calculate progress.
  if (!empty($total_strings)) {
    $translations = \Drupal::service('locale.storage')->countTranslations();
    foreach ($translations as $langcode => $translated) {
      $stats[$langcode]['translated'] = $translated;
      if ($translated > 0) {
        $stats[$langcode]['ratio'] = round($translated / $total_strings * 100, 2);
      }
    }
  }

  array_splice($form['languages']['#header'], -1, 0, t('Interface translation'));

  foreach ($languages as $langcode => $language) {
    $stats[$langcode] += array(
      'translated' => 0,
      'ratio' => 0,
    );
    if (!$language->locked && ($langcode != 'en' || locale_translate_english())) {
      $form['languages'][$langcode]['locale_statistics'] = array(
        '#markup' => l(
          t('@translated/@total (@ratio%)', array(
            '@translated' => $stats[$langcode]['translated'],
            '@total' => $total_strings,
            '@ratio' => $stats[$langcode]['ratio'],
          )),
          'admin/config/regional/translate',
          array('query' => array('langcode' => $langcode))
        ),
      );
    }
    else {
      $form['languages'][$langcode]['locale_statistics'] = array(
        '#markup' => t('not applicable'),
      );
    }
    // #type = link doesn't work with #weight on table.
    // reset and set it back after locale_statistics to get it at the right end.
    $operations = $form['languages'][$langcode]['operations'];
    unset($form['languages'][$langcode]['operations']);
    $form['languages'][$langcode]['operations'] = $operations;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for language_admin_add_form().
 */
function locale_form_language_admin_add_form_alter(&$form, FormStateInterface $form_state) {
  $form['predefined_submit']['#submit'][] = 'locale_form_language_admin_add_form_alter_submit';
  $form['custom_language']['submit']['#submit'][] = 'locale_form_language_admin_add_form_alter_submit';
}

/**
 * Form submission handler for language_admin_add_form().
 *
 * Set a batch for a newly-added language.
 */
function locale_form_language_admin_add_form_alter_submit($form, FormStateInterface $form_state) {
  if (\Drupal::config('locale.settings')->get('translation.import_enabled')) {
    if (empty($form_state['values']['predefined_langcode']) || $form_state['values']['predefined_langcode'] == 'custom') {
      $langcode = $form_state['values']['langcode'];
    }
    else {
      $langcode = $form_state['values']['predefined_langcode'];
    }

    // Download and import translations for the newly added language.
    module_load_include('fetch.inc', 'locale');
    $options = _locale_translation_default_update_options();
    $batch = locale_translation_batch_update_build(array(), array($langcode), $options);
    batch_set($batch);

    // Create or update all configuration translations for this language.
    \Drupal::moduleHandler()->loadInclude('locale', 'bulk.inc');
    if ($batch = locale_config_batch_update_components($options, array($langcode))) {
      batch_set($batch);
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for language_admin_edit_form().
 */
function locale_form_language_admin_edit_form_alter(&$form, FormStateInterface $form_state) {
  if ($form['langcode']['#type'] == 'value' && $form['langcode']['#value'] == 'en') {
    $form['locale_translate_english'] = array(
      '#title' => t('Enable interface translation to English'),
      '#type' => 'checkbox',
      '#default_value' => locale_translate_english(),
    );
    $form['actions']['submit']['#submit'][] = 'locale_form_language_admin_edit_form_alter_submit';
  }
}

/**
 * Form submission handler for language_admin_edit_form().
 */
function locale_form_language_admin_edit_form_alter_submit($form, FormStateInterface $form_state) {
  \Drupal::config('locale.settings')->set('translate_english', intval($form_state['values']['locale_translate_english']))->save();
}

/**
 * Checks whether locale translates to English.
 *
 * @return bool
 *   Returns TRUE if content should be translated to English, FALSE otherwise.
 */
function locale_translate_english() {
  return \Drupal::config('locale.settings')->get('translate_english');
}

/**
 * Implements hook_form_FORM_ID_alter() for system_file_system_settings().
 *
 * Add interface translation directory setting to directories configuration.
 */
function locale_form_system_file_system_settings_alter(&$form, FormStateInterface $form_state) {
  $form['translation_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Interface translations directory'),
    '#default_value' => \Drupal::config('locale.settings')->get('translation.path'),
    '#maxlength' => 255,
    '#description' => t('A local file system path where interface translation files will be stored.'),
    '#required' => TRUE,
    '#after_build' => array('system_check_directory'),
    '#weight' => 10,
  );
  if ($form['file_default_scheme']) {
    $form['file_default_scheme']['#weight'] = 20;
  }
  $form['#submit'][] = 'locale_system_file_system_settings_submit';
}

/**
 * Submit handler for the file system settings form.
 *
 * Clears the translation status when the Interface translations directory
 * changes. Without a translations directory local po files in the directory
 * should be ignored. The old translation status is no longer valid.
 */
function locale_system_file_system_settings_submit(&$form, FormStateInterface $form_state) {
  if ($form['translation_path']['#default_value'] != $form_state['values']['translation_path']) {
    locale_translation_clear_status();
  }

  \Drupal::config('locale.settings')
    ->set('translation.path', $form_state['values']['translation_path'])
    ->save();
}

/**
 * Implements hook_preprocess_HOOK() for node templates.
 */
function locale_preprocess_node(&$variables) {
  if ($variables['node']->language()->id != LanguageInterface::LANGCODE_NOT_SPECIFIED) {
    $language_interface = \Drupal::languageManager()->getCurrentLanguage();

    $node_language = $variables['node']->language();
    if ($node_language->id != $language_interface->id) {
      // If the node language was different from the page language, we should
      // add markup to identify the language. Otherwise the page language is
      // inherited.
      $variables['attributes']['lang'] = $node_language->id;
      if ($node_language->direction != $language_interface->direction) {
        // If text direction is different form the page's text direction, add
        // direction information as well.
        $dir = array('ltr', 'rtl');
        $variables['attributes']['dir'] = $dir[$node_language->direction];
      }
    }
  }
}

/**
 * Gets current translation status from the {locale_file} table.
 *
 * @return array
 *   Array of translation file objects.
 */
function locale_translation_get_file_history() {
  $history = &drupal_static(__FUNCTION__, array());

  if (empty($history)) {
    // Get file history from the database.
    $result = db_query('SELECT project, langcode, filename, version, uri, timestamp, last_checked FROM {locale_file}');
    foreach ($result as $file) {
      $file->type = $file->timestamp ? LOCALE_TRANSLATION_CURRENT : '';
      $history[$file->project][$file->langcode] = $file;
    }
  }
  return $history;
}

/**
 * Updates the {locale_file} table.
 *
 * @param object $file
 *   Object representing the file just imported.
 *
 * @return int
 *   FALSE on failure. Otherwise SAVED_NEW or SAVED_UPDATED.
 */
function locale_translation_update_file_history($file) {
  $status = db_merge('locale_file')
    ->key(array(
      'project' => $file->project,
      'langcode' => $file->langcode,
    ))
    ->fields(array(
      'version' => $file->version,
      'timestamp' => $file->timestamp,
      'last_checked' => $file->last_checked,
    ))
    ->execute();
  // The file history has changed, flush the static cache now.
  // @todo Can we make this more fine grained?
  drupal_static_reset('locale_translation_get_file_history');
  return $status;
}

/**
 * Deletes the history of downloaded translations.
 *
 * @param array $projects
 *   Project name(s) to be deleted from the file history. If both project(s) and
 *   language code(s) are specified the conditions will be ANDed.
 * @param array $langcodes
 *   Language code(s) to be deleted from the file history.
 */
function locale_translation_file_history_delete($projects = array(), $langcodes = array()) {
  $query = db_delete('locale_file');
  if (!empty($projects)) {
    $query->condition('project', $projects);
  }
  if (!empty($langcodes)) {
    $query->condition('langcode', $langcodes);
  }
  $query->execute();
}

/**
 * Gets the current translation status.
 *
 * @todo What is 'translation status'?
 */
function locale_translation_get_status($projects = NULL, $langcodes = NULL) {
  $result = array();
  $status = \Drupal::state()->get('locale.translation_status');
  module_load_include('translation.inc', 'locale');
  $projects = $projects ? $projects : array_keys(locale_translation_get_projects());
  $langcodes = $langcodes ? $langcodes : array_keys(locale_translatable_language_list());

  // Get the translation status of each project-language combination. If no
  // status was stored, a new translation source is created.
  foreach ($projects as $project) {
    foreach ($langcodes as $langcode) {
      if (isset($status[$project][$langcode])) {
        $result[$project][$langcode] = $status[$project][$langcode];
      }
      else {
        $sources = locale_translation_build_sources(array($project), array($langcode));
        if (isset($sources[$project][$langcode])) {
          $result[$project][$langcode] = $sources[$project][$langcode];
        }
      }
    }
  }
  return $result;
}

/**
 * Saves the status of translation sources in static cache.
 *
 * @param string $project
 *   Machine readable project name.
 * @param string $langcode
 *   Language code.
 * @param string $type
 *   Type of data to be stored.
 * @param array $data
 *   File object also containing timestamp when the translation is last updated.
 */
function locale_translation_status_save($project, $langcode, $type, $data) {
  // Followup issue: http://drupal.org/node/1842362
  // Split status storage per module/language and expire individually. This will
  // improve performance for large sites.

  // Load the translation status or build it if not already available.
  module_load_include('translation.inc', 'locale');
  $status = locale_translation_get_status();
  if (empty($status)) {
    $projects = locale_translation_get_projects(array($project));
    if (isset($projects[$project])) {
      $status[$project][$langcode] = locale_translation_source_build($projects[$project], $langcode);
    }
  }

  // Merge the new status data with the existing status.
  if (isset($status[$project][$langcode])) {
    switch ($type) {
      case LOCALE_TRANSLATION_REMOTE:
      case LOCALE_TRANSLATION_LOCAL:
        // Add the source data to the status array.
        $status[$project][$langcode]->files[$type] = $data;

        // Check if this translation is the most recent one. Set timestamp and
        // data type of the most recent translation source.
        if (isset($data->timestamp) && $data->timestamp) {
          if ($data->timestamp > $status[$project][$langcode]->timestamp) {
            $status[$project][$langcode]->timestamp = $data->timestamp;
            $status[$project][$langcode]->last_checked = REQUEST_TIME;
            $status[$project][$langcode]->type = $type;
          }
        }
        break;

      case LOCALE_TRANSLATION_CURRENT:
        $data->last_checked = REQUEST_TIME;
        $status[$project][$langcode]->timestamp = $data->timestamp;
        $status[$project][$langcode]->last_checked = $data->last_checked;
        $status[$project][$langcode]->type = $type;
        locale_translation_update_file_history($data);
        break;
    }

    \Drupal::state()->set('locale.translation_status', $status);
    \Drupal::state()->set('locale.translation_last_checked', REQUEST_TIME);
  }
}

/**
 * Delete language entries from the status cache.
 *
 * @param array $langcodes
 *   Language code(s) to be deleted from the cache.
 */
function locale_translation_status_delete_languages($langcodes) {
  if ($status = locale_translation_get_status()) {
    foreach ($status as $project => $languages) {
      foreach ($languages as $langcode => $source) {
        if (in_array($langcode, $langcodes)) {
          unset($status[$project][$langcode]);
        }
      }
    }
    \Drupal::state()->set('locale.translation_status', $status);
  }
}

/**
 * Delete project entries from the status cache.
 *
 * @param array $projects
 *   Project name(s) to be deleted from the cache.
 */
function locale_translation_status_delete_projects($projects) {
  $status = locale_translation_get_status();

  foreach ($status as $project => $languages) {
    if (in_array($project, $projects)) {
      unset($status[$project]);
    }
  }
  \Drupal::state()->set('locale.translation_status', $status);
}

/**
 * Clear the translation status cache.
 */
function locale_translation_clear_status() {
  \Drupal::state()->delete('locale.translation_status');
  \Drupal::state()->delete('locale.translation_last_checked');
}

/**
 * Checks whether remote translation sources are used.
 *
 * @return bool
 *   Returns TRUE if remote translations sources should be taken into account
 *   when checking or importing translation files, FALSE otherwise.
 */
function locale_translation_use_remote_source() {
  return \Drupal::config('locale.settings')->get('translation.use_source') == LOCALE_TRANSLATION_USE_SOURCE_REMOTE_AND_LOCAL;
}

/**
 * Check that a string is safe to be added or imported as a translation.
 *
 * This test can be used to detect possibly bad translation strings. It should
 * not have any false positives. But it is only a test, not a transformation,
 * as it destroys valid HTML. We cannot reliably filter translation strings
 * on import because some strings are irreversibly corrupted. For example,
 * a &amp; in the translation would get encoded to &amp;amp; by
 * \Drupal\Component\Utility\Xss::filter() before being put in the database,
 * and thus would be displayed incorrectly.
 *
 * The allowed tag list is like \Drupal\Component\Utility\Xss::filterAdmin(),
 * but omitting div and img as not needed for translation and likely to cause
 * layout issues (div) or a possible attack vector (img).
 */
function locale_string_is_safe($string) {
  return decode_entities($string) == decode_entities(Xss::filter($string, array('a', 'abbr', 'acronym', 'address', 'b', 'bdo', 'big', 'blockquote', 'br', 'caption', 'cite', 'code', 'col', 'colgroup', 'dd', 'del', 'dfn', 'dl', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'ins', 'kbd', 'li', 'ol', 'p', 'pre', 'q', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'ul', 'var')));
}

/**
 * Refresh related information after string translations have been updated.
 *
 * The information that will be refreshed includes:
 * - JavaScript translations.
 * - Locale cache.
 *
 * @param array $langcodes
 *   Language codes for updated translations.
 * @param array $lids
 *   (optional) List of string identifiers that have been updated / created.
 *   If not provided, all caches for the affected languages are cleared.
 */
function _locale_refresh_translations($langcodes, $lids = array()) {
  if (!empty($langcodes)) {
    // Update javascript translations if any of the strings has a javascript
    // location, or if no string ids were provided, update all languages.
    if (empty($lids) || ($strings = \Drupal::service('locale.storage')->getStrings(array('lid' => $lids, 'type' => 'javascript')))) {
      array_map('_locale_invalidate_js', $langcodes);
    }
  }
  // Clear locale cache.
  Cache::deleteTags(array('locale' => TRUE));
}

/**
 * Refreshes configuration after string translations have been updated.
 *
 * The information that will be refreshed includes:
 * - JavaScript translations.
 * - Locale cache.
 *
 * @param array $langcodes
 *   Language codes for updated translations.
 * @param array $lids
 *   List of string identifiers that have been updated / created.
 */
function _locale_refresh_configuration(array $langcodes, array $lids) {
  if ($lids && $langcodes && $names = \Drupal\locale\Locale::config()->getStringNames($lids)) {
    \Drupal::moduleHandler()->loadInclude('locale', 'bulk.inc');
    locale_config_update_multiple($names, $langcodes);
  }
}

/**
 * Removes the quotes and string concatenations from the string.
 *
 * @param string $string
 *   Single or double quoted strings, optionally concatenated by plus (+) sign.
 *
 * @return string
 *   String with leading and trailing quotes removed.
 */
function _locale_strip_quotes($string) {
  return implode('', preg_split('~(?<!\\\\)[\'"]\s*\+\s*[\'"]~s', substr($string, 1, -1)));
}

/**
 * Parses a JavaScript file, extracts strings wrapped in Drupal.t() and
 * Drupal.formatPlural() and inserts them into the database.
 *
 * @param string $filepath
 *   File name to parse.
 *
 * @return array
 *   Array of string objects to update indexed by context and source.
 *
 * @throws Exception
 *   If a non-local file is attempted to be parsed.
 */
function _locale_parse_js_file($filepath) {
  // The file path might contain a query string, so make sure we only use the
  // actual file.
  $parsed_url = UrlHelper::parse($filepath);
  $filepath = $parsed_url['path'];

  // If there is still a protocol component in the path, reject that.
  if (strpos($filepath, ':')) {
    throw new Exception('Only local files should be passed to _locale_parse_js_file().');
  }

  // Load the JavaScript file.
  $file = file_get_contents($filepath);

  // Match all calls to Drupal.t() in an array.
  // Note: \s also matches newlines with the 's' modifier.
  preg_match_all('~
    [^\w]Drupal\s*\.\s*t\s*                       # match "Drupal.t" with whitespace
    \(\s*                                         # match "(" argument list start
    (' . LOCALE_JS_STRING . ')\s*                 # capture string argument
    (?:,\s*' . LOCALE_JS_OBJECT . '\s*            # optionally capture str args
      (?:,\s*' . LOCALE_JS_OBJECT_CONTEXT . '\s*) # optionally capture context
    ?)?                                           # close optional args
    [,\)]                                         # match ")" or "," to finish
    ~sx', $file, $t_matches);

  // Match all Drupal.formatPlural() calls in another array.
  preg_match_all('~
    [^\w]Drupal\s*\.\s*formatPlural\s*  # match "Drupal.formatPlural" with whitespace
    \(                                  # match "(" argument list start
    \s*.+?\s*,\s*                       # match count argument
    (' . LOCALE_JS_STRING . ')\s*,\s*   # match singular string argument
    (                             # capture plural string argument
      (?:                         # non-capturing group to repeat string pieces
        (?:
          \'                      # match start of single-quoted string
          (?:\\\\\'|[^\'])*       # match any character except unescaped single-quote
          @count                  # match "@count"
          (?:\\\\\'|[^\'])*       # match any character except unescaped single-quote
          \'                      # match end of single-quoted string
          |
          "                       # match start of double-quoted string
          (?:\\\\"|[^"])*         # match any character except unescaped double-quote
          @count                  # match "@count"
          (?:\\\\"|[^"])*         # match any character except unescaped double-quote
          "                       # match end of double-quoted string
        )
        (?:\s*\+\s*)?             # match "+" with possible whitespace, for str concat
      )+                          # match multiple because we supports concatenating strs
    )\s*                          # end capturing of plural string argument
    (?:,\s*' . LOCALE_JS_OBJECT . '\s*          # optionally capture string args
      (?:,\s*' . LOCALE_JS_OBJECT_CONTEXT . '\s*)?  # optionally capture context
    )?
    [,\)]
    ~sx', $file, $plural_matches);

  $matches = array();

  // Add strings from Drupal.t().
  foreach ($t_matches[1] as $key => $string) {
    $matches[] = array(
      'source'  => _locale_strip_quotes($string),
      'context' => _locale_strip_quotes($t_matches[2][$key]),
    );
  }

  // Add string from Drupal.formatPlural().
  foreach ($plural_matches[1] as $key => $string) {
    $matches[] = array(
      'source'  => _locale_strip_quotes($string) . LOCALE_PLURAL_DELIMITER . _locale_strip_quotes($plural_matches[2][$key]),
      'context' => _locale_strip_quotes($plural_matches[3][$key]),
    );
  }

  // Loop through all matches and process them.
  foreach ($matches as $match) {
    $source = \Drupal::service('locale.storage')->findString($match);

    if (!$source) {
      // We don't have the source string yet, thus we insert it into the
      // database.
      $source = \Drupal::service('locale.storage')->createString($match);
    }

    // Besides adding the location this will tag it for current version.
    $source->addLocation('javascript', $filepath);
    $source->save();
  }
}

/**
 * Force the JavaScript translation file(s) to be refreshed.
 *
 * This function sets a refresh flag for a specified language, or all
 * languages except English, if none specified. JavaScript translation
 * files are rebuilt (with locale_update_js_files()) the next time a
 * request is served in that language.
 *
 * @param $langcode
 *   The language code for which the file needs to be refreshed.
 *
 * @return
 *   New content of the 'system.javascript_parsed' variable.
 */
function _locale_invalidate_js($langcode = NULL) {
  $parsed = \Drupal::state()->get('system.javascript_parsed') ?: array();

  if (empty($langcode)) {
    // Invalidate all languages.
    $languages = locale_translatable_language_list();
    foreach ($languages as $lcode => $data) {
      $parsed['refresh:' . $lcode] = 'waiting';
    }
  }
  else {
    // Invalidate single language.
    $parsed['refresh:' . $langcode] = 'waiting';
  }

  \Drupal::state()->set('system.javascript_parsed', $parsed);
  return $parsed;
}

/**
 * (Re-)Creates the JavaScript translation file for a language.
 *
 * @param $langcode
 *   The language, the translation file should be (re)created for.
 *
 * @return bool
 *   TRUE if translation file exists, FALSE otherwise.
 */
function _locale_rebuild_js($langcode = NULL) {
  $config = \Drupal::config('locale.settings');
  if (!isset($langcode)) {
    $language = \Drupal::languageManager()->getCurrentLanguage();
  }
  else {
    // Get information about the locale.
    $languages = \Drupal::languageManager()->getLanguages();
    $language = $languages[$langcode];
  }

  // Construct the array for JavaScript translations.
  // Only add strings with a translation to the translations array.
  $conditions = array(
    'type' => 'javascript',
    'language' => $language->id,
    'translated' => TRUE,
  );
  $translations = array();
  foreach (\Drupal::service('locale.storage')->getTranslations($conditions) as $data) {
    $translations[$data->context][$data->source] = $data->translation;
  }

  // Construct the JavaScript file, if there are translations.
  $data_hash = NULL;
  $data = $status = '';
  if (!empty($translations)) {
    $data = array(
      'strings' => $translations,
    );

    $locale_plurals = \Drupal::state()->get('locale.translation.plurals') ?: array();
    if (!empty($locale_plurals[$language->id]['formula'])) {
      $data['pluralFormula'] = $locale_plurals[$language->id]['formula'];
    }

    $data = 'Drupal.locale = ' . Json::encode($data) . ';';
    $data_hash = Crypt::hashBase64($data);
  }

  // Construct the filepath where JS translation files are stored.
  // There is (on purpose) no front end to edit that variable.
  $dir = 'public://' . $config->get('javascript.directory');

  // Delete old file, if we have no translations anymore, or a different file to
  // be saved.
  $locale_javascripts = \Drupal::state()->get('locale.translation.javascript') ?: array();
  $changed_hash = !isset($locale_javascripts[$language->id]) || ($locale_javascripts[$language->id] != $data_hash);
  if (!empty($locale_javascripts[$language->id]) && (!$data || $changed_hash)) {
    file_unmanaged_delete($dir . '/' . $language->id . '_' . $locale_javascripts[$language->id] . '.js');
    $locale_javascripts[$language->id] = '';
    $status = 'deleted';
  }

  // Only create a new file if the content has changed or the original file got
  // lost.
  $dest = $dir . '/' . $language->id . '_' . $data_hash . '.js';
  if ($data && ($changed_hash || !file_exists($dest))) {
    // Ensure that the directory exists and is writable, if possible.
    file_prepare_directory($dir, FILE_CREATE_DIRECTORY);

    // Save the file.
    if (file_unmanaged_save_data($data, $dest)) {
      $locale_javascripts[$language->id] = $data_hash;
      // If we deleted a previous version of the file and we replace it with a
      // new one we have an update.
      if ($status == 'deleted') {
        $status = 'updated';
      }
      // If the file did not exist previously and the data has changed we have
      // a fresh creation.
      elseif ($changed_hash) {
        $status = 'created';
      }
      // If the data hash is unchanged the translation was lost and has to be
      // rebuilt.
      else {
        $status = 'rebuilt';
      }
    }
    else {
      $locale_javascripts[$language->id] = '';
      $status = 'error';
    }
  }

  // Save the new JavaScript hash (or an empty value if the file just got
  // deleted). Act only if some operation was executed that changed the hash
  // code.
  if ($status && $changed_hash) {
    \Drupal::state()->set('locale.translation.javascript', $locale_javascripts);
  }

  // Log the operation and return success flag.
  $logger = \Drupal::logger('locale');
  switch ($status) {
    case 'updated':
      $logger->notice('Updated JavaScript translation file for the language %language.', array('%language' => $language->name));
      return TRUE;

    case 'rebuilt':
      $logger->warning('JavaScript translation file %file.js was lost.', array('%file' => $locale_javascripts[$language->id]));
      // Proceed to the 'created' case as the JavaScript translation file has
      // been created again.

    case 'created':
      $logger->notice('Created JavaScript translation file for the language %language.', array('%language' => $language->name));
      return TRUE;

    case 'deleted':
      $logger->notice('Removed JavaScript translation file for the language %language because no translations currently exist for that language.', array('%language' => $language->name));
      return TRUE;

    case 'error':
      $logger->error('An error occurred during creation of the JavaScript translation file for the language %language.', array('%language' => $language->name));
      return FALSE;

    default:
      // No operation needed.
      return TRUE;
  }
}
/**
 * Form element callback: After build changes to the language update table.
 *
 * Adds labels to the languages and removes checkboxes from languages from which
 * translation files could not be found.
 */
function locale_translation_language_table($form_element) {
  // Remove checkboxes of languages without updates.
  if ($form_element['#not_found']) {
    foreach ($form_element['#not_found'] as $langcode) {
      $form_element[$langcode] = array();
    }
  }
  return $form_element;
}

