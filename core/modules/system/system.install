<?php

/**
 * @file
 * Install, update and uninstall functions for the system module.
 */

use Drupal\Component\Utility\Crypt;
use Drupal\Core\Database\Database;
use Drupal\Core\Language\Language;
use Drupal\Core\StreamWrapper\PublicStream;

/**
 * Implements hook_requirements().
 */
function system_requirements($phase) {
  $requirements = array();

  // Report Drupal version
  if ($phase == 'runtime') {
    $requirements['drupal'] = array(
      'title' => t('Drupal'),
      'value' => \Drupal::VERSION,
      'severity' => REQUIREMENT_INFO,
      'weight' => -10,
    );

    // Display the currently active installation profile, if the site
    // is not running the default installation profile.
    $profile = drupal_get_profile();
    if ($profile != 'standard') {
      $info = system_get_info('module', $profile);
      $requirements['install_profile'] = array(
        'title' => t('Installation profile'),
        'value' => t('%profile_name (%profile-%version)', array(
          '%profile_name' => $info['name'],
          '%profile' => $profile,
          '%version' => $info['version']
        )),
        'severity' => REQUIREMENT_INFO,
        'weight' => -9
      );
    }
  }

  // Web server information.
  $software = \Drupal::request()->server->get('SERVER_SOFTWARE');
  $requirements['webserver'] = array(
    'title' => t('Web server'),
    'value' => $software,
  );

  // Test PHP version and show link to phpinfo() if it's available
  $phpversion = phpversion();
  if (function_exists('phpinfo')) {
    $requirements['php'] = array(
      'title' => t('PHP'),
      'value' => ($phase == 'runtime') ? $phpversion .' ('. l(t('more information'), 'admin/reports/status/php') .')' : $phpversion,
    );
  }
  else {
    $requirements['php'] = array(
      'title' => t('PHP'),
      'value' => $phpversion,
      'description' => t('The phpinfo() function has been disabled for security reasons. To see your server\'s phpinfo() information, change your PHP settings or contact your server administrator. For more information, <a href="@phpinfo">Enabling and disabling phpinfo()</a> handbook page.', array('@phpinfo' => 'http://drupal.org/node/243993')),
      'severity' => REQUIREMENT_INFO,
    );
  }

  if (version_compare($phpversion, DRUPAL_MINIMUM_PHP) < 0) {
    $requirements['php']['description'] = t('Your PHP installation is too old. Drupal requires at least PHP %version.', array('%version' => DRUPAL_MINIMUM_PHP));
    $requirements['php']['severity'] = REQUIREMENT_ERROR;
    // If PHP is old, it's not safe to continue with the requirements check.
    return $requirements;
  }

  // Test PHP register_globals setting.
  $requirements['php_register_globals'] = array(
    'title' => t('PHP register globals'),
  );
  $register_globals = trim(ini_get('register_globals'));
  // Unfortunately, ini_get() may return many different values, and we can't
  // be certain which values mean 'on', so we instead check for 'not off'
  // since we never want to tell the user that their site is secure
  // (register_globals off), when it is in fact on. We can only guarantee
  // register_globals is off if the value returned is 'off', '', or 0.
  if (!empty($register_globals) && strtolower($register_globals) != 'off') {
    $requirements['php_register_globals']['description'] = t('<em>register_globals</em> is enabled. Drupal requires this configuration directive to be disabled. Your site may not be secure when <em>register_globals</em> is enabled. The PHP manual has instructions for <a href="@url">how to change configuration settings</a>.', array('@url' => 'http://php.net/configuration.changes'));
    $requirements['php_register_globals']['severity'] = REQUIREMENT_ERROR;
    $requirements['php_register_globals']['value'] = t("Enabled ('@value')", array('@value' => $register_globals));
  }
  else {
    $requirements['php_register_globals']['value'] = t('Disabled');
  }

  // Test for PHP extensions.
  $requirements['php_extensions'] = array(
    'title' => t('PHP extensions'),
  );

  $missing_extensions = array();
  $required_extensions = array(
    'date',
    'dom',
    'filter',
    'gd',
    'hash',
    'json',
    'pcre',
    'pdo',
    'session',
    'SimpleXML',
    'SPL',
    'tokenizer',
    'xml',
  );
  foreach ($required_extensions as $extension) {
    if (!extension_loaded($extension)) {
      $missing_extensions[] = $extension;
    }
  }

  if (!empty($missing_extensions)) {
    $description = t('Drupal requires you to enable the PHP extensions in the following list (see the <a href="@system_requirements">system requirements page</a> for more information):', array(
      '@system_requirements' => 'http://drupal.org/requirements',
    ));

    $item_list = array(
      '#theme' => 'item_list',
      '#items' => $missing_extensions,
    );
    $description .= drupal_render($item_list);

    $requirements['php_extensions']['value'] = t('Disabled');
    $requirements['php_extensions']['severity'] = REQUIREMENT_ERROR;
    $requirements['php_extensions']['description'] = $description;
  }
  else {
    $requirements['php_extensions']['value'] = t('Enabled');
  }

  if ($phase == 'install' || $phase == 'update') {
    // Test for PDO (database).
    $requirements['database_extensions'] = array(
      'title' => t('Database support'),
    );

    // Make sure PDO is available.
    $database_ok = extension_loaded('pdo');
    if (!$database_ok) {
      $pdo_message = t('Your web server does not appear to support PDO (PHP Data Objects). Ask your hosting provider if they support the native PDO extension. See the <a href="@link">system requirements</a> page for more information.', array(
        '@link' => 'http://drupal.org/requirements/pdo',
      ));
    }
    else {
      // Make sure at least one supported database driver exists.
      $drivers = drupal_detect_database_types();
      if (empty($drivers)) {
        $database_ok = FALSE;
        $pdo_message = t('Your web server does not appear to support any common PDO database extensions. Check with your hosting provider to see if they support PDO (PHP Data Objects) and offer any databases that <a href="@drupal-databases">Drupal supports</a>.', array(
          '@drupal-databases' => 'http://drupal.org/node/270#database',
        ));
      }
      // Make sure the native PDO extension is available, not the older PEAR
      // version. (See install_verify_pdo() for details.)
      if (!defined('PDO::ATTR_DEFAULT_FETCH_MODE')) {
        $database_ok = FALSE;
        $pdo_message = t('Your web server seems to have the wrong version of PDO installed. Drupal requires the PDO extension from PHP core. This system has the older PECL version. See the <a href="@link">system requirements</a> page for more information.', array(
          '@link' => 'http://drupal.org/requirements/pdo#pecl',
        ));
      }
    }

    if (!$database_ok) {
      $requirements['database_extensions']['value'] = t('Disabled');
      $requirements['database_extensions']['severity'] = REQUIREMENT_ERROR;
      $requirements['database_extensions']['description'] = $pdo_message;
    }
    else {
      $requirements['database_extensions']['value'] = t('Enabled');
    }
  }
  else {
    // Database information.
    $class = Database::getConnection()->getDriverClass('Install\\Tasks');
    $tasks = new $class();
    $requirements['database_system'] = array(
      'title' => t('Database system'),
      'value' => $tasks->name(),
    );
    $requirements['database_system_version'] = array(
      'title' => t('Database system version'),
      'value' => Database::getConnection()->version(),
    );
  }

  // Test PHP memory_limit
  $memory_limit = ini_get('memory_limit');
  $requirements['php_memory_limit'] = array(
    'title' => t('PHP memory limit'),
    'value' => $memory_limit == -1 ? t('-1 (Unlimited)') : $memory_limit,
  );

  if (!drupal_check_memory_limit(DRUPAL_MINIMUM_PHP_MEMORY_LIMIT, $memory_limit)) {
    $description = '';
    if ($phase == 'install') {
      $description = t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the installation process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }
    elseif ($phase == 'update') {
      $description = t('Consider increasing your PHP memory limit to %memory_minimum_limit to help prevent errors in the update process.', array('%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }
    elseif ($phase == 'runtime') {
      $description = t('Depending on your configuration, Drupal can run with a %memory_limit PHP memory limit. However, a %memory_minimum_limit PHP memory limit or above is recommended, especially if your site uses additional custom or contributed modules.', array('%memory_limit' => $memory_limit, '%memory_minimum_limit' => DRUPAL_MINIMUM_PHP_MEMORY_LIMIT));
    }

    if (!empty($description)) {
      if ($php_ini_path = get_cfg_var('cfg_file_path')) {
        $description .= ' ' . t('Increase the memory limit by editing the memory_limit parameter in the file %configuration-file and then restart your web server (or contact your system administrator or hosting provider for assistance).', array('%configuration-file' => $php_ini_path));
      }
      else {
        $description .= ' ' . t('Contact your system administrator or hosting provider for assistance with increasing your PHP memory limit.');
      }

      $requirements['php_memory_limit']['description'] = $description . ' ' . t('For more information, see the online handbook entry for <a href="@memory-limit">increasing the PHP memory limit</a>.', array('@memory-limit' => 'http://drupal.org/node/207036'));
      $requirements['php_memory_limit']['severity'] = REQUIREMENT_WARNING;
    }
  }

  // Test configuration files and directory for writability.
  if ($phase == 'runtime') {
    $conf_errors = array();
    $conf_path = conf_path();
    if (!drupal_verify_install_file($conf_path, FILE_NOT_WRITABLE, 'dir')) {
      $conf_errors[] = t("The directory %file is not protected from modifications and poses a security risk. You must change the directory's permissions to be non-writable.", array('%file' => $conf_path));
    }
    foreach (array('settings.php', 'settings.local.php') as $conf_file) {
      $full_path = $conf_path . '/' . $conf_file;
      if (file_exists($full_path) && !drupal_verify_install_file($full_path, FILE_EXIST|FILE_READABLE|FILE_NOT_WRITABLE)) {
        $conf_errors[] = t("The file %file is not protected from modifications and poses a security risk. You must change the file's permissions to be non-writable.", array('%file' => $full_path));
      }
    }
    if (!empty($conf_errors)) {
      if (count($conf_errors) == 1) {
        $description = $conf_errors[0];
      }
      else {
        $item_list = array(
          '#theme' => 'item_list',
          '#items' => $conf_errors,
        );
        $description = drupal_render($item_list);
      }
      $requirements['settings.php'] = array(
        'value' => t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => $description,
      );
    }
    else {
      $requirements['settings.php'] = array(
        'value' => t('Protected'),
      );
    }
    $requirements['settings.php']['title'] = t('Configuration files');
  }

  // Report cron status.
  if ($phase == 'runtime') {
    $cron_config = \Drupal::config('system.cron');
    // Cron warning threshold defaults to two days.
    $threshold_warning = $cron_config->get('threshold.requirements_warning');
    // Cron error threshold defaults to two weeks.
    $threshold_error = $cron_config->get('threshold.requirements_error');
    // Cron configuration help text.
    $help = t('For more information, see the online handbook entry for <a href="@cron-handbook">configuring cron jobs</a>.', array('@cron-handbook' => 'http://drupal.org/cron'));

    // Determine when cron last ran.
    $cron_last = \Drupal::state()->get('system.cron_last');
    if (!is_numeric($cron_last)) {
      $cron_last = \Drupal::state()->get('install_time', 0);
    }

    // Determine severity based on time since cron last ran.
    $severity = REQUIREMENT_INFO;
    if (REQUEST_TIME - $cron_last > $threshold_error) {
      $severity = REQUIREMENT_ERROR;
    }
    elseif (REQUEST_TIME - $cron_last > $threshold_warning) {
      $severity = REQUIREMENT_WARNING;
    }

    // Set summary and description based on values determined above.
    $summary = t('Last run !time ago', array('!time' => format_interval(REQUEST_TIME - $cron_last)));
    $description = '';
    if ($severity != REQUIREMENT_INFO) {
      $description = t('Cron has not run recently.') . ' ' . $help;
    }

    $description .= ' ' . t('You can <a href="@cron">run cron manually</a>.', array('@cron' => url('admin/reports/status/run-cron')));
    $description .= '<br />' . t('To run cron from outside the site, go to <a href="!cron">!cron</a>', array('!cron' => url('cron/' . \Drupal::state()->get('system.cron_key'), array('absolute' => TRUE))));

    $requirements['cron'] = array(
      'title' => t('Cron maintenance tasks'),
      'severity' => $severity,
      'value' => $summary,
      'description' => $description
    );
  }
  if ($phase != 'install') {
    $filesystem_config = \Drupal::config('system.file');
    $directories = array(
      PublicStream::basePath(),
      // By default no private files directory is configured. For private files
      // to be secure the admin needs to provide a path outside the webroot.
      $filesystem_config->get('path.private'),
      file_directory_temp(),
    );
  }

  // During an install we need to make assumptions about the file system
  // unless overrides are provided in settings.php.
  if ($phase == 'install') {
    global $conf;
    $directories = array();
    if ($file_public_path = settings()->get('file_public_path')) {
      $directories[] = $file_public_path;
    }
    else {
      // If we are installing Drupal, the settings.php file might not exist yet
      // in the intended conf_path() directory, so don't require it. The
      // conf_path() cache must also be reset in this case.
      $directories[] = conf_path(FALSE, TRUE) . '/files';
    }
    if (!empty($conf['system.file']['path.private'])) {
      $directories[] = $conf['system.file']['path.private'];
    }
    if (!empty($conf['system.file']['path.temporary'])) {
      $directories[] = $conf['system.file']['path.temporary'];
    }
    else {
      // If the temporary directory is not overridden use an appropriate
      // temporary path for the system.
      $directories[] = file_directory_os_temp();
    }
  }

  // Check the config directory if it is defined in settings.php. If it isn't
  // defined, the installer will create a valid config directory later, but
  // during runtime we must always display an error.
  if (!empty($GLOBALS['config_directories'])) {
    $directories[] = config_get_config_directory(CONFIG_ACTIVE_DIRECTORY);
    $directories[] = config_get_config_directory(CONFIG_STAGING_DIRECTORY);
  }
  elseif ($phase != 'install') {
    $requirements['config directories'] = array(
      'title' => t('Configuration directories'),
      'value' => t('Not present'),
      'description' => t('Your %file file must define the $config_directories variable as an array containing the name of a directories in which configuration files can be written.', array('%file' => conf_path() . '/settings.php')),
      'severity' => REQUIREMENT_ERROR,
    );
  }

  $requirements['file system'] = array(
    'title' => t('File system'),
  );

  $error = '';
  // For installer, create the directories if possible.
  foreach ($directories as $directory) {
    if (!$directory) {
      continue;
    }
    if ($phase == 'install') {
      $mode = isset($GLOBALS['install_state']['mode']) ? $GLOBALS['install_state']['mode'] : NULL;
      file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS, $mode);
    }
    $is_writable = is_writable($directory);
    $is_directory = is_dir($directory);
    if (!$is_writable || !$is_directory) {
      $description = '';
      $requirements['file system']['value'] = t('Not writable');
      if (!$is_directory) {
        $error .= t('The directory %directory does not exist.', array('%directory' => $directory)) . ' ';
      }
      else {
        $error .= t('The directory %directory is not writable.', array('%directory' => $directory)) . ' ';
      }
      // The files directory requirement check is done only during install and runtime.
      if ($phase == 'runtime') {
        $description = $error . t('You may need to set the correct directory at the <a href="@admin-file-system">file system settings page</a> or change the current directory\'s permissions so that it is writable.', array('@admin-file-system' => url('admin/config/media/file-system')));
      }
      elseif ($phase == 'install') {
        // For the installer UI, we need different wording. 'value' will
        // be treated as version, so provide none there.
        $description = $error . t('An automated attempt to create this directory failed, possibly due to a permissions problem. To proceed with the installation, either create the directory and modify its permissions manually or ensure that the installer has the permissions to create it automatically. For more information, see INSTALL.txt or the <a href="@handbook_url">online handbook</a>.', array('@handbook_url' => 'http://drupal.org/server-permissions'));
        $requirements['file system']['value'] = '';
      }
      if (!empty($description)) {
        $requirements['file system']['description'] = $description;
        $requirements['file system']['severity'] = REQUIREMENT_ERROR;
      }
    }
    else {
      // This function can be called before the config_cache table has been
      // created.
      if ($phase == 'install' || file_default_scheme() == 'public') {
        $requirements['file system']['value'] = t('Writable (<em>public</em> download method)');
      }
      else {
        $requirements['file system']['value'] = t('Writable (<em>private</em> download method)');
      }
    }
  }

  // See if updates are available in update.php.
  if ($phase == 'runtime') {
    $requirements['update'] = array(
      'title' => t('Database updates'),
      'value' => t('Up to date'),
    );

    // Check installed modules.
    foreach (\Drupal::moduleHandler()->getModuleList() as $module => $filename) {
      $updates = drupal_get_schema_versions($module);
      if ($updates !== FALSE) {
        $default = drupal_get_installed_schema_version($module);
        if (max($updates) > $default) {
          $requirements['update']['severity'] = REQUIREMENT_ERROR;
          $requirements['update']['value'] = t('Out of date');
          $requirements['update']['description'] = t('Some modules have database schema updates to install. You should run the <a href="@update">database update script</a> immediately.', array('@update' => base_path() . 'core/update.php'));
          break;
        }
      }
    }
  }

  // Verify the update.php access setting
  if ($phase == 'runtime') {
    if (settings()->get('update_free_access')) {
      $requirements['update access'] = array(
        'value' => t('Not protected'),
        'severity' => REQUIREMENT_ERROR,
        'description' => t('The update.php script is accessible to everyone without authentication check, which is a security risk. You must change the @settings_name value in your settings.php back to FALSE.', array('@settings_name' => '$settings[\'update_free_access\']')),
      );
    }
    else {
      $requirements['update access'] = array(
        'value' => t('Protected'),
      );
    }
    $requirements['update access']['title'] = t('Access to update.php');
  }

  // Display an error if a newly introduced dependency in a module is not resolved.
  if ($phase == 'update') {
    $profile = drupal_get_profile();
    $files = system_rebuild_module_data();
    foreach ($files as $module => $file) {
      // Ignore disabled modules and installation profiles.
      if (!$file->status || $module == $profile) {
        continue;
      }
      // Check the module's PHP version.
      $name = $file->info['name'];
      $php = $file->info['php'];
      if (version_compare($php, PHP_VERSION, '>')) {
        $requirements['php']['description'] .= t('@name requires at least PHP @version.', array('@name' => $name, '@version' => $php));
        $requirements['php']['severity'] = REQUIREMENT_ERROR;
      }
      // Check the module's required modules.
      foreach ($file->requires as $requirement) {
        $required_module = $requirement['name'];
        // Check if the module exists.
        if (!isset($files[$required_module])) {
          $requirements["$module-$required_module"] = array(
            'title' => t('Unresolved dependency'),
            'description' => t('@name requires this module.', array('@name' => $name)),
            'value' => t('@required_name (Missing)', array('@required_name' => $required_module)),
            'severity' => REQUIREMENT_ERROR,
          );
          continue;
        }
        // Check for an incompatible version.
        $required_file = $files[$required_module];
        $required_name = $required_file->info['name'];
        $version = str_replace(\Drupal::CORE_COMPATIBILITY . '-', '', $required_file->info['version']);
        $compatibility = drupal_check_incompatibility($requirement, $version);
        if ($compatibility) {
          $compatibility = rtrim(substr($compatibility, 2), ')');
          $requirements["$module-$required_module"] = array(
            'title' => t('Unresolved dependency'),
            'description' => t('@name requires this module and version. Currently using @required_name version @version', array('@name' => $name, '@required_name' => $required_name, '@version' => $version)),
            'value' => t('@required_name (Version @compatibility required)', array('@required_name' => $required_name, '@compatibility' => $compatibility)),
            'severity' => REQUIREMENT_ERROR,
          );
          continue;
        }
      }
    }
  }

  // Test Unicode library
  include_once DRUPAL_ROOT . '/core/includes/unicode.inc';
  $requirements = array_merge($requirements, unicode_requirements());

  if ($phase == 'runtime') {
    // Check for update status module.
    if (!\Drupal::moduleHandler()->moduleExists('update')) {
      $requirements['update status'] = array(
        'value' => t('Not enabled'),
        'severity' => REQUIREMENT_WARNING,
        'description' => t('Update notifications are not enabled. It is <strong>highly recommended</strong> that you enable the Update Manager module from the <a href="@module">module administration page</a> in order to stay up-to-date on new releases. For more information, <a href="@update">Update status handbook page</a>.', array('@update' => 'http://drupal.org/documentation/modules/update', '@module' => url('admin/modules'))),
      );
    }
    else {
      $requirements['update status'] = array(
        'value' => t('Enabled'),
      );
    }
    $requirements['update status']['title'] = t('Update notifications');
  }

  // Ensure that if upgrading from 7 to 8 we have no disabled modules.
  if ($phase == 'update' && db_table_exists('system')) {
    $modules = db_query('SELECT name, info FROM {system} WHERE type = :module AND status = 0 AND schema_version <> :schema_uninstalled', array(
      ':module' => 'module',
      ':schema_uninstalled' => SCHEMA_UNINSTALLED,
    ))->fetchAllKeyed(0, 1);
    array_walk($modules, function (&$value, $key) {
      $info = unserialize($value);
      $value = $info['name'];
    });
    if (!empty($modules)) {
      $requirements['disabled_modules'] = array(
        'severity' => REQUIREMENT_ERROR,
        'title' => t('Disabled modules'),
        'value' => format_plural(count($modules), 'The %modules module is disabled.', 'The following modules are disabled: %modules', array('%modules' => implode(', ', $modules))),
        'description' => t('Drupal 8 no longer supports disabled modules. Please either enable or uninstall them before upgrading.'),
      );
    }
  }
  return $requirements;
}

/**
 * Implements hook_install().
 */
function system_install() {
  // Enable and set the default theme. Can't use theme_enable() this early in
  // installation.
  config_install_default_config('theme', 'stark');
  \Drupal::config('system.theme')
    ->set('default', 'stark')
    ->save();

  // Populate the cron key state variable.
  $cron_key = Crypt::randomStringHashed(55);
  \Drupal::state()->set('system.cron_key', $cron_key);
}

/**
 * Implements hook_schema().
 */
function system_schema() {
  // NOTE: {variable} needs to be created before all other tables, as
  // some database drivers, e.g. Oracle and DB2, will require variable_get()
  // and variable_set() for overcoming some database specific limitations.
  $schema['variable'] = array(
    'description' => 'Named variable/value pairs created by Drupal core or any other module or theme. All variables are cached in memory at the start of every Drupal request so developers should not be careless about what is stored here.',
    'fields' => array(
      'name' => array(
        'description' => 'The name of the variable.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'value' => array(
        'description' => 'The value of the variable.',
        'type' => 'blob',
        'not null' => TRUE,
        'size' => 'big',
      ),
    ),
    'primary key' => array('name'),
  );

  $schema['batch'] = array(
    'description' => 'Stores details about batches (processes that run in multiple HTTP requests).',
    'fields' => array(
      'bid' => array(
        'description' => 'Primary Key: Unique batch ID.',
        // This is not a serial column, to allow both progressive and
        // non-progressive batches. See batch_process().
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'token' => array(
        'description' => "A string token generated against the current user's session id and the batch id, used to ensure that only the user who submitted the batch can effectively access it.",
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
      ),
      'timestamp' => array(
        'description' => 'A Unix timestamp indicating when this batch was submitted for processing. Stale batches are purged at cron time.',
        'type' => 'int',
        'not null' => TRUE,
      ),
      'batch' => array(
        'description' => 'A serialized array containing the processing data for the batch.',
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
      ),
    ),
    'primary key' => array('bid'),
    'indexes' => array(
      'token' => array('token'),
    ),
  );

  $schema['flood'] = array(
    'description' => 'Flood controls the threshold of events, such as the number of contact attempts.',
    'fields' => array(
      'fid' => array(
        'description' => 'Unique flood event ID.',
        'type' => 'serial',
        'not null' => TRUE,
      ),
      'event' => array(
        'description' => 'Name of event (e.g. contact).',
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
        'default' => '',
      ),
      'identifier' => array(
        'description' => 'Identifier of the visitor, such as an IP address or hostname.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'timestamp' => array(
        'description' => 'Timestamp of the event.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'expiration' => array(
        'description' => 'Expiration timestamp. Expired events are purged on cron run.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('fid'),
    'indexes' => array(
      'allow' => array('event', 'identifier', 'timestamp'),
      'purge' => array('expiration'),
    ),
  );

  $schema['key_value'] = array(
    'description' => 'Generic key-value storage table. See the state system for an example.',
    'fields' => array(
      'collection' => array(
        'description' => 'A named collection of key and value pairs.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'name' => array(
        'description' => 'The key of the key-value pair. As KEY is a SQL reserved keyword, name was chosen instead.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'value' => array(
        'description' => 'The value.',
        'type' => 'blob',
        'not null' => TRUE,
        'size' => 'big',
      ),
    ),
    'primary key' => array('collection', 'name'),
  );

  $schema['key_value_expire'] = array(
    'description' => 'Generic key/value storage table with an expiration.',
    'fields' => array(
      'collection' => array(
        'description' => 'A named collection of key and value pairs.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'name' => array(
        // KEY is an SQL reserved word, so use 'name' as the key's field name.
        'description' => 'The key of the key/value pair.',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'value' => array(
        'description' => 'The value of the key/value pair.',
        'type' => 'blob',
        'not null' => TRUE,
        'size' => 'big',
      ),
      'expire' => array(
        'description' => 'The time since Unix epoch in seconds when this item expires. Defaults to the maximum possible time.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 2147483647,
      ),
    ),
    'primary key' => array('collection', 'name'),
    'indexes' => array(
      'all' => array('name', 'collection', 'expire'),
    ),
  );

  $schema['menu_router'] = array(
    'description' => 'Maps paths to various callbacks (access, page and title)',
    'fields' => array(
      'path' => array(
        'description' => 'Primary Key: the Drupal path this entry describes',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'load_functions' => array(
        'description' => 'A serialized array of function names (like node_load) to be called to load an object corresponding to a part of the current path.',
        'type' => 'blob',
        'not null' => TRUE,
      ),
      'to_arg_functions' => array(
        'description' => 'A serialized array of function names (like user_uid_optional_to_arg) to be called to replace a part of the router path with another string.',
        'type' => 'blob',
        'not null' => TRUE,
      ),
      'access_callback' => array(
        'description' => 'The callback which determines the access to this router path. Defaults to user_access.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'access_arguments' => array(
        'description' => 'A serialized array of arguments for the access callback.',
        'type' => 'blob',
        'not null' => FALSE,
      ),
      'page_callback' => array(
        'description' => 'The name of the function that renders the page.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'page_arguments' => array(
        'description' => 'A serialized array of arguments for the page callback.',
        'type' => 'blob',
        'not null' => FALSE,
      ),
      'fit' => array(
        'description' => 'A numeric representation of how specific the path is.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'number_parts' => array(
        'description' => 'Number of parts in this router path.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small',
      ),
      'context' => array(
        'description' => 'Only for local tasks (tabs) - the context of a local task to control its placement.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'tab_parent' => array(
        'description' => 'Only for local tasks (tabs) - the router path of the parent page (which may also be a local task).',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'tab_root' => array(
        'description' => 'Router path of the closest non-tab parent page. For pages that are not local tasks, this will be the same as the path.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'title' => array(
        'description' => 'The title for the current page, or the title for the tab if this is a local task.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'title_callback' => array(
        'description' => 'A function which will alter the title. Defaults to t()',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'title_arguments' => array(
        'description' => 'A serialized array of arguments for the title callback. If empty, the title will be used as the sole argument for the title callback.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'theme_callback' => array(
        'description' => 'A function which returns the name of the theme that will be used to render this page. If left empty, the default theme will be used.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'theme_arguments' => array(
        'description' => 'A serialized array of arguments for the theme callback.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'type' => array(
        'description' => 'Numeric representation of the type of the menu item, like MENU_LOCAL_TASK.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'description' => array(
        'description' => 'A description of this item.',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'description_callback' => array(
        'description' => 'A function which will alter the description. Defaults to t().',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'description_arguments' => array(
        'description' => 'A serialized array of arguments for the description callback. If empty, the description will be used as the sole argument for the description callback.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'position' => array(
        'description' => 'The position of the block (left or right) on the system administration page for this item.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'weight' => array(
        'description' => 'Weight of the element. Lighter weights are higher up, heavier weights go down.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'include_file' => array(
        'description' => 'The file to include for this element, usually the page callback function lives in this file.',
        'type' => 'text',
        'size' => 'medium',
      ),
      'route_name' => array(
        'description' => 'The machine name of a defined Symfony Route this menu item represents.',
        'type' => 'varchar',
        'length' => 255,
      ),
    ),
    'indexes' => array(
      'fit' => array('fit'),
      'tab_parent' => array(array('tab_parent', 64), 'weight', 'title'),
      'tab_root_weight_title' => array(array('tab_root', 64), 'weight', 'title'),
    ),
    'primary key' => array('path'),
  );

  $schema['queue'] = array(
    'description' => 'Stores items in queues.',
    'fields' => array(
      'item_id' => array(
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'description' => 'Primary Key: Unique item ID.',
      ),
      'name' => array(
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
        'description' => 'The queue name.',
      ),
      'data' => array(
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
        'serialize' => TRUE,
        'description' => 'The arbitrary data for the item.',
      ),
      'expire' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Timestamp when the claim lease expires on the item.',
      ),
      'created' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' => 'Timestamp when the item was created.',
      ),
    ),
    'primary key' => array('item_id'),
    'indexes' => array(
      'name_created' => array('name', 'created'),
      'expire' => array('expire'),
    ),
  );

  $schema['router'] = array(
    'description' => 'Maps paths to various callbacks (access, page and title)',
    'fields' => array(
      'name' => array(
        'description' => 'Primary Key: Machine name of this route',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'path' => array(
        'description' => 'The path for this URI',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'pattern_outline' => array(
        'description' => 'The pattern',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'provider' => array(
        'description' => 'The provider grouping to which a route belongs.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'fit' => array(
        'description' => 'A numeric representation of how specific the path is.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'route' => array(
        'description' => 'A serialized Route object',
        'type' => 'text',
      ),
      'number_parts' => array(
        'description' => 'Number of parts in this router path.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small',
      ),
    ),
    'indexes' => array(
      'pattern_outline_fit' => array('pattern_outline', 'fit'),
      'provider' => array('provider'),
    ),
    'primary key' => array('name'),
  );

  $schema['semaphore'] = array(
    'description' => 'Table for holding semaphores, locks, flags, etc. that cannot be stored as Drupal variables since they must not be cached.',
    'fields' => array(
      'name' => array(
        'description' => 'Primary Key: Unique name.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'value' => array(
        'description' => 'A value for the semaphore.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'expire' => array(
        'description' => 'A Unix timestamp with microseconds indicating when the semaphore should expire.',
        'type' => 'float',
        'size' => 'big',
        'not null' => TRUE
      ),
    ),
    'indexes' => array(
      'value' => array('value'),
      'expire' => array('expire'),
    ),
    'primary key' => array('name'),
  );

  $schema['sequences'] = array(
    'description' => 'Stores IDs.',
    'fields' => array(
      'value' => array(
        'description' => 'The value of the sequence.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
     ),
    'primary key' => array('value'),
  );

  $schema['sessions'] = array(
    'description' => "Drupal's session handlers read and write into the sessions table. Each record represents a user session, either anonymous or authenticated.",
    'fields' => array(
      'uid' => array(
        'description' => 'The {users}.uid corresponding to a session, or 0 for anonymous user.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'sid' => array(
        'description' => "A session ID. The value is generated by Drupal's session handlers.",
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
      ),
      'ssid' => array(
        'description' => "Secure session ID. The value is generated by Drupal's session handlers.",
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'hostname' => array(
        'description' => 'The IP address that last used this session ID (sid).',
        'type' => 'varchar',
        'length' => 128,
        'not null' => TRUE,
        'default' => '',
      ),
      'timestamp' => array(
        'description' => 'The Unix timestamp when this session last requested a page. Old records are purged by PHP automatically.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'session' => array(
        'description' => 'The serialized contents of $_SESSION, an array of name/value pairs that persists across page requests by this session ID. Drupal loads $_SESSION from here at the start of each request and saves it at the end.',
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
      ),
    ),
    'primary key' => array(
      'sid',
      'ssid',
    ),
    'indexes' => array(
      'timestamp' => array('timestamp'),
      'uid' => array('uid'),
      'ssid' => array('ssid'),
    ),
    'foreign keys' => array(
      'session_user' => array(
        'table' => 'users',
        'columns' => array('uid' => 'uid'),
      ),
    ),
  );

  $schema['url_alias'] = array(
    'description' => 'A list of URL aliases for Drupal paths; a user may visit either the source or destination path.',
    'fields' => array(
      'pid' => array(
        'description' => 'A unique path alias identifier.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'source' => array(
        'description' => 'The Drupal path this alias is for; e.g. node/12.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'alias' => array(
        'description' => 'The alias for this path; e.g. title-of-the-story.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'langcode' => array(
        'description' => "The language code this alias is for; if 'und', the alias will be used for unknown languages. Each Drupal path can have an alias for each supported language.",
        'type' => 'varchar',
        'length' => 12,
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'primary key' => array('pid'),
    'indexes' => array(
      'alias_langcode_pid' => array('alias', 'langcode', 'pid'),
      'source_langcode_pid' => array('source', 'langcode', 'pid'),
    ),
  );

  $schema['config_snapshot'] = array(
    'description' => 'Stores a snapshot of the last imported configuration.',
    'fields' => array(
      'name' => array(
        'description' => 'The identifier for the config object (the name of the file, minus the file extension).',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'The raw data for this configuration object.',
        'type' => 'blob',
        'not null' => TRUE,
        'size' => 'big',
      ),
    ),
    'primary key' => array('name'),
  );

  return $schema;
}

/**
 * The cache schema corresponding to Drupal 8.0.
 *
 * Helper function to add cache tables in the Drupal 7 to 8 upgrade path
 * without relying on system_schema(), which may change with future updates.
 */
function system_schema_cache_8007() {
  return array(
    'description' => 'Generic cache table for caching things not separated out into their own tables. Contributed modules may also use this to store cached items.',
    'fields' => array(
      'cid' => array(
        'description' => 'Primary Key: Unique cache ID.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'A collection of data to cache.',
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
      ),
      'expire' => array(
        'description' => 'A Unix timestamp indicating when the cache entry should expire, or 0 for never.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'created' => array(
        'description' => 'A Unix timestamp indicating when the cache entry was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'serialized' => array(
        'description' => 'A flag to indicate whether content is serialized (1) or not (0).',
        'type' => 'int',
        'size' => 'small',
        'not null' => TRUE,
        'default' => 0,
      ),
      'tags' => array(
        'description' => 'Space-separated list of cache tags for this entry.',
        'type' => 'text',
        'size' => 'big',
        'not null' => FALSE,
      ),
      'checksum_invalidations' => array(
        'description' => 'The tag invalidation sum when this entry was saved.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'checksum_deletions' => array(
        'description' => 'The tag deletion sum when this entry was saved.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'indexes' => array(
      'expire' => array('expire'),
    ),
    'primary key' => array('cid'),
  );
}

// Updates for core.

function system_update_last_removed() {
  return 7069;
}

//Do not copy @defgroup to other files. Use @addtogroup instead.
/**
 * @defgroup config_upgrade Configuration system upgrade functions
 * @{
 * Module update functions that
 * - update variables prior to configuration system conversions
 * - convert variables to the new configuration system
 * - update configuration system values after conversion
 *
 * @} End of "defgroup config_upgrade".
 */

/**
 * @defgroup updates-7.x-to-8.x Updates from 7.x to 8.x
 * @{
 * Update functions from 7.x to 8.x.
 */

/**
 * Move from the Garland theme.
 */
function system_update_8001() {
  $themes = array('theme_default', 'maintenance_theme', 'admin_theme');
  foreach ($themes as $theme) {
    if (update_variable_get($theme) == 'garland') {
      update_variable_set($theme, 'bartik');
    }
  }
}

/**
 * Set 'node' as front page path and Bartik as default theme if it implicitly was before.
 *
 * Node module became optional. The default front page path was changed to
 * 'user'. Since 'node' was the implicit default front page path previously and
 * may not have been explicitly configured as such, this update ensures that the
 * old implicit default is still the default.
 *
 * @see http://drupal.org/node/375397
 *
 * The default theme for Drupal core was changed from Bartik to Stark.
 * Installation profiles (including Standard and Minimal) were changed to
 * explicitly configure Bartik as default theme. Since Bartik was the default
 * theme by default and may not have been explicitly configured as such
 * previously, this update ensures that the implicit Bartik default is still the
 * default.
 *
 * @see http://drupal.org/node/1181776
 *
 * @ingroup config_upgrade
 */
function system_update_8002() {
  $front_page = update_variable_get('site_frontpage');
  if (!isset($front_page)) {
    update_variable_set('site_frontpage', 'node');
  }
  $theme = update_variable_get('theme_default');
  if (!isset($theme)) {
    update_variable_set('theme_default', 'bartik');
  }
}

/**
 * Create {cache_config} cache table for the new configuration system.
 */
function system_update_8003() {
  // Moved to update_prepare_d8_bootstrap.
}

/**
 * Add {file_managed}.langcode field.
 *
 * @see http://drupal.org/node/1454538
 */
function system_update_8004() {
  $langcode_field = array(
    'description' => 'The {language}.langcode of this file.',
    'type' => 'varchar',
    'length' => 12,
    'not null' => TRUE,
    'default' => '',
  );

  // If a Drupal 7 contrib module already added a langcode field to support
  // internationalization, keep it, but standardize the specification.
  // Otherwise, add the field.
  if (db_field_exists('file_managed', 'langcode')) {
    // According to the documentation of db_change_field(), indices using the
    // field should be dropped first; if the contrib module created any indices,
    // it is its responsibility to drop them in an update function that runs
    // before this one, which it can enforce via hook_update_dependencies().
    db_change_field('file_managed', 'langcode', 'langcode', $langcode_field);
  }
  else {
    // Files can be language-specific (e.g., a scanned document) or not (e.g.,
    // a photograph). For a site being updated, Drupal does not have a way to
    // determine which existing files are language-specific and in what
    // language. Our best guess is to set all of them to Language::LANGCODE_NOT_SPECIFIED.
    $langcode_field['initial'] = Language::LANGCODE_NOT_SPECIFIED;
    db_add_field('file_managed', 'langcode', $langcode_field);
  }
}

/**
 * Remove the obsolete {session}.cache column.
 */
function system_update_8005() {
  db_drop_field('session', 'cache');
}

/**
 * Add the {cache_tags} table.
 */
function system_update_8006() {
  // Moved to update_prepare_d8_bootstrap.
}

/**
 * Modify existing cache tables, adding support for cache tags.
 */
function system_update_8007() {
  // Moved to update_prepare_d8_bootstrap.
}

/**
 * Remove the 'clean_url' configuration variable.
 */
function system_update_8008() {
  update_variable_del('clean_url');
}

/**
 * Move cron system settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8009() {
  update_variables_to_config('system.cron', array(
    'cron_safe_threshold' => 'threshold.autorun',
    'cron_threshold_warning' => 'threshold.requirements_warning',
    'cron_threshold_error' => 'threshold.requirements_error',
  ));
}

/**
 * Move RSS system settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8010() {
  update_variables_to_config('system.rss', array(
    'feed_description' => 'channel.description',
    'feed_default_items' => 'items.limit',
    'feed_item_length' => 'items.view_mode',
  ));
}

/**
 * Update the module and base fields for the blog node type.
 */
function system_update_8011() {
  db_update('node_type')
    ->fields(array(
      'module' => 'node',
      'base' => 'node_content',
    ))
    ->condition('module', 'blog')
    ->execute();
}

/**
 * Move site system settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8012() {
  update_variables_to_config('system.site', array(
    'site_name' => 'name',
    'site_mail' => 'mail',
    'site_slogan' => 'slogan',
    'site_frontpage' => 'page.front',
    'site_403' => 'page.403',
    'site_404' => 'page.404',
    'drupal_weight_select_max' => 'weight_select_max',
  ));
}

/**
 * Add description_callback and description_arguments fields to {menu_router}.
 */
function system_update_8013() {
  if (!db_field_exists('menu_router', 'description_callback')) {
    $spec = array(
      'description' => 'A function which will alter the description. Defaults to t().',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    );
    db_add_field('menu_router', 'description_callback', $spec);
  }
  if (!db_field_exists('menu_router', 'description_arguments')) {
    $spec = array(
      'description' => 'A serialized array of arguments for the description callback. If empty, the description will be used as the sole argument for the description callback.',
      'type' => 'varchar',
      'length' => 255,
      'not null' => TRUE,
      'default' => '',
    );
    db_add_field('menu_router', 'description_arguments', $spec);
  }
}

/**
 * Move system logging settings from variables to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8014() {
  // Not using update_variables_to_config(), since the only value is
  // 'error_level', which needs to be mapped to a new value.
  $config = \Drupal::config('system.logging');
  $error_level = db_query("SELECT value FROM {variable} WHERE name = 'error_level'")->fetchField();
  if ($error_level !== FALSE) {
    $error_level = unserialize($error_level);
    $map = array(
      '0' => 'hide',
      '1' => 'some',
      '2' => 'all',
      '3' => 'verbose',
    );
    // Update error_level value to a string identifier.
    $config->set('error_level', $map[$error_level]);
    // Delete the migrated variable.
    db_delete('variable')->condition('name', 'error_level')->execute();
  }
  else {
    // Set error_level to the default value.
    $config->set('error_level', 'all');
  }
  $config->save();
}

/**
 * Create a UUID column for managed files.
 */
function system_update_8015() {
  $spec = array(
    'description' => 'Unique Key: Universally unique identifier for this entity.',
    'type' => 'varchar',
    'length' => 128,
    'not null' => FALSE,
  );
  $keys = array(
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
  );
  // Account for sites having the contributed UUID module installed.
  if (db_field_exists('file_managed', 'uuid')) {
    db_change_field('file_managed', 'uuid', 'uuid', $spec, $keys);
  }
  else {
    db_add_field('file_managed', 'uuid', $spec, $keys);
  }
}

/**
 * Move the system maintenance settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8016() {
  update_variables_to_config('system.maintenance', array(
    'maintenance_mode_message' => 'message',
  ));
  update_variables_to_state(array(
    'maintenance_mode' => 'system.maintenance_mode',
  ));
}

/**
 * Move system performance settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8017() {
  update_variables_to_config('system.performance', array(
    'cache' => 'cache.page.use_internal',
    'page_cache_maximum_age' => 'cache.page.max_age',
    'page_compression' => 'response.gzip',
    'preprocess_css' => 'css.preprocess',
    'preprocess_js' => 'js.preprocess',
    'stale_file_threshold' => 'stale_file_threshold',
  ));
}

/**
 * Remove the registry tables.
 */
function system_update_8019() {
  db_drop_table('registry');
  db_drop_table('registry_file');
}

/**
 * Conditionally enable the new Ban module.
 */
function system_update_8020() {
  $blocked_ips_exists = db_query_range('SELECT 1 FROM {blocked_ips}', 0, 1)->fetchField();
  if ($blocked_ips_exists) {
    // Rename the permission name.
    update_replace_permissions(array(
      'block IP addresses' => array('ban IP addresses'),
    ));
    // Rename {blocked_ips} table into {ban_ip}.
    db_rename_table('blocked_ips', 'ban_ip');
    // Remove all references to the removed action callback.
    db_delete('actions')
      ->condition('callback', 'system_block_ip_action')
      ->execute();
    db_delete('actions')
      ->condition('aid', 'system_block_ip_action')
      ->execute();
    // Enable the new Ban module.
    \Drupal::moduleHandler()->install(array('ban'));
  }
  else {
    // Drop old table.
    db_drop_table('blocked_ips');
  }
}

/**
 * Enable the Actions module.
 */
function system_update_8021() {
  // Enable the module without re-installing the schema.
  \Drupal::moduleHandler()->install(array('action'));
  // Rename former System module actions.
  $map = array(
    'system_message_action' => 'action_message_action',
    'system_send_email_action' => 'action_send_email_action',
    'system_goto_action' => 'action_goto_action',
  );
  foreach ($map as $old => $new) {
    // Rename all references to the action callback.
    db_update('actions')
      ->fields(array('callback' => $new))
      ->condition('callback', $old)
      ->execute();
    // Rename the action's aid.
    db_update('actions')
      ->fields(array('aid' => $new))
      ->condition('aid', $old)
      ->execute();
  }
}

/**
 * Create the new routing table.
 */
function system_update_8022() {

  $tables['router'] = array(
    'description' => 'Maps paths to various callbacks (access, page and title)',
    'fields' => array(
      'name' => array(
        'description' => 'Primary Key: Machine name of this route',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'path' => array(
        'description' => 'The path for this URI',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'pattern_outline' => array(
        'description' => 'The pattern',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'provider' => array(
        'description' => 'The provider grouping to which a route belongs.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'fit' => array(
        'description' => 'A numeric representation of how specific the path is.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'route' => array(
        'description' => 'A serialized Route object',
        'type' => 'text',
      ),
      'number_parts' => array(
        'description' => 'Number of parts in this router path.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'small',
      ),
    ),
    'indexes' => array(
      'pattern_outline_fit' => array('pattern_outline', 'fit'),
      'provider' => array('provider'),
    ),
    'primary key' => array('name'),
  );

  $schema = Database::getConnection()->schema();

  $schema->dropTable('router');

  $schema->createTable('router', $tables['router']);
}

/**
 * Create the 'key_value_expire' table.
 */
function system_update_8023() {
  // Moved to update_fix_d8_requirements() as it is required early.
}

/**
 * Generate a UUID for all files.
 */
function system_update_8024(&$sandbox) {
  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['last'] = 0;
    $sandbox['max'] = db_query('SELECT COUNT(fid) FROM {file_managed} WHERE uuid IS NULL')->fetchField();
  }

  $fids = db_query_range('SELECT fid FROM {file_managed} WHERE fid > :fid AND uuid IS NULL ORDER BY fid ASC', 0, 10, array(':fid' => $sandbox['last']))->fetchCol();
  update_add_uuids($sandbox, 'file_managed', 'fid', $fids);

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress'] / $sandbox['max']);
}

/**
 * Remove {system} table.
 */
function system_update_8025() {
  db_drop_table('system');
}

/**
 * Clean up javascript_parsed variable.
 *
 * @ingroup system_upgrade
 */
function system_update_8027() {
  update_variable_del('javascript_parsed');
}

/**
 * Remove the 'menu_masks' configuration variable.
 */
function system_update_8028() {
  // No upgrade path needed since the menu router will be rebuilt during the
  // Drupal 7 to Drupal 8 upgrade.
  update_variable_del('menu_masks');
}

/**
 * Convert path_alias_whitelist variable to state API.
 *
 * @ingroup state_upgrade
 */
function system_update_8029() {
  if ($value = update_variable_get('path_alias_whitelist', FALSE)) {
    \Drupal::state()->set('system.path_alias_whitelist', $value);
  }
  update_variable_del('path_alias_whitelist');
}

 /**
 * Move authorize system settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8030() {
  update_variables_to_config('system.authorize', array(
    'authorize_filetransfer_default' => 'filetransfer_default',
  ));
}

/**
 * Rename default menu names.
 */
function system_update_8031() {
  $map = array(
    'navigation' => 'tools',
    'management' => 'admin',
    'user-menu' => 'account',
    'main-menu' => 'main',
  );
  foreach ($map as $old => $new) {
    db_update('menu_links')
      ->condition('menu_name', $old)
      ->fields(array('menu_name' => $new))
      ->execute();
  }
}

/**
 * Remove the drupal_js_cache_files and css_js_query_string variables.
 *
 * @ingroup config_upgrade
 */
function system_update_8032() {
  update_variable_del('drupal_js_cache_files');
  update_variable_del('css_js_query_string');
}

/**
 * Convert active_menus_default variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8033() {
  update_variables_to_config('system.menu', array(
    'menu_default_active_menus' => 'active_menus_default'
  ));
}

/**
 * Move cron last run time and cron key from variable to state.
 *
 * @ingroup config_upgrade
 */
function system_update_8034() {
  update_variables_to_state(array(
    'cron_last' => 'system.cron_last',
    'cron_key' => 'system.cron_key',
    ));
}

/**
 * Move filter_allowed_protocols variable to config.
 *
 * This config is provided now by the system module because it is used by
 * \Drupal\Component\Utility\Url::stripDangerousProtocols() and must to be
 * available before the filter module be installed.
 *
 * @ingroup config_upgrade
 */
function system_update_8035() {
  update_variables_to_config('system.filter', array(
    'filter_allowed_protocols' => 'protocols',
  ));
}

/**
 * Move the admin_compact_mode setting from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8036() {
  update_variables_to_config('system.site', array(
    'admin_compact_mode' => 'admin_compact_mode',
  ));
}

/**
 * Remove the 'password_count_log2' variable.
 *
 * @ingroup config_upgrade
 */
function system_update_8037() {
  update_variable_del('password_count_log2');
}

/**
 * Move site system regional settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8038() {
  update_variables_to_config('system.date', array(
    'site_default_country' => 'country.default',
    'date_first_day' => 'first_day',
    'date_default_timezone' => 'timezone.default',
    'configurable_timezones' => 'timezone.user.configurable',
    'empty_timezone_message' => 'timezone.user.warn',
    'user_default_timezone' => 'timezone.user.default',
  ));
}

/**
 * Convert css and js gzip compression variables to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8039() {
  $variable_map = array(
    'css_gzip_compression' => 'css.gzip',
    'js_gzip_compression' => 'js.gzip'
  );
  update_variables_to_config('system.performance', $variable_map);
}

/**
 * Move action_max_stack from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8040() {
  update_variables_to_config('action.settings', array(
    'actions_max_stack' => 'recursion_limit',
  ));
}

/**
 * Convert admin_theme variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8041() {
  update_variables_to_config('system.theme', array(
    'admin_theme' => 'admin',
    'theme_default' => 'default'
  ));
}

/**
 * Enable the new Entity module.
 */
function system_update_8042() {
  \Drupal::moduleHandler()->install(array('entity'));
}

/**
 * Move system fast 404 settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8044() {
  update_variables_to_config('system.performance', array(
    'fast_404_html' => 'fast_404.html',
    'fast_404_paths' => 'fast_404.paths',
    'fast_404_paths_exclude' => 'fast_404.exclude_paths',
  ));
}

/**
 * Convert existing date formats to the new config system.
 *
 * @ingroup config_upgrade
 */
function system_update_8045() {
  $uuid = \Drupal::service('uuid');
  // Fetch all date types from {date_format_type}.
  $date_formats = db_query('SELECT * FROM {date_format_type}')->fetchAllAssoc('type', PDO::FETCH_ASSOC);
  if (!empty($date_formats)) {
    foreach ($date_formats as $type => $format) {
      // Set name and locked properties.
      $config = \Drupal::config("system.date_format.$type")
        ->set('id', $type)
        ->set('label', $format['title'])
        ->set('locked', $format['locked'])
        ->set('status', 1)
        ->set('uuid', $uuid->generate());

      // Get the default date format for this type.
      $variable_name = 'date_format_' . $type;
      $default_format = update_variable_get($variable_name, NULL);
      if ($default_format) {
        // In Drupal 7 we only used PHP date types.
        $config->set('pattern.php', $default_format);

        // Delete the migrated variables.
        update_variable_del($variable_name);
      }
      // Save the date configuration object.
      $config->save();
    }
  }

  // Install the new HTML date formats.
  $new_formats = array(
    'system.date_format.fallback',
    'system.date_format.html_date',
    'system.date_format.html_datetime',
    'system.date_format.html_month',
    'system.date_format.html_time',
    'system.date_format.html_week',
    'system.date_format.html_year',
    'system.date_format.html_yearless_date',
  );
  foreach ($new_formats as $new_format) {
    update_install_default_config('module', $new_format);
  }
}

/**
 * Install new default views.
 */
function system_update_8046() {
  update_install_default_config('module', 'views.view.user_admin_people', 'user');
  update_install_default_config('module', 'views.view.content', 'node');

  $front_page = \Drupal::config('system.site')->get('page.front') ?: 'node';
  if ($front_page == 'node') {
    // This imports the node frontpage view.
    update_install_default_config('module', 'views.view.frontpage', 'node');
  }
}

/**
 * Move site system settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8047() {
  update_variables_to_config('system.file', array(
    'allow_insecure_uploads' => 'allow_insecure_uploads',
    'file_default_scheme' => 'default_scheme',
    'file_chmod_directory' => 'chmod.directory',
    'file_chmod_file' => 'chmod.file',
    'file_private_path' => 'path.private',
    'file_temporary_path' => 'path.temporary',
  ));
}

/**
 * Enable the new Menu link module.
 *
 * Creates the langcode and UUID columns for menu links.
 */
function system_update_8048() {
  // Enable the module without re-installing the schema.
  \Drupal::moduleHandler()->install(array('menu_link'));

  // Add the langcode column if it doesn't exist.
  if (!db_field_exists('menu_inks', 'langcode')) {
    $column = array(
      'description' => 'The {language}.langcode of this entity.',
      'type' => 'varchar',
      'length' => 12,
      'not null' => TRUE,
      'default' => '',
    );
    db_add_field('menu_links', 'langcode', $column);
  }

  // Add the UUID column.
  $column = array(
    'description' => 'Unique Key: Universally unique identifier for this entity.',
    'type' => 'varchar',
    'length' => 128,
    'not null' => FALSE,
  );
  $keys = array(
    'unique keys' => array(
      'uuid' => array('uuid'),
    ),
  );
  db_add_field('menu_links', 'uuid', $column, $keys);
}

/**
 * Create the 'config_snapshot' table.
 */
function system_update_8049() {
  $table = array(
    'description' => 'Stores a snapshot of the last imported configuration.',
    'fields' => array(
      'name' => array(
        'description' => 'The identifier for the config object (the name of the file, minus the file extension).',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'data' => array(
        'description' => 'The raw data for this configuration object.',
        'type' => 'blob',
        'not null' => TRUE,
        'size' => 'big',
      ),
    ),
    'primary key' => array('name'),
  );

  db_create_table('config_snapshot', $table);
}

/**
 * Convert mail settings to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8050() {
  // Update any mail interfaces to their Drupal 8 equivalents.
  $old_mail_system_settings = update_variable_get('mail_system');

  if ($old_mail_system_settings) {
    $new_mail_system_settings = array();

    foreach ($old_mail_system_settings as $key => $mailer_class) {
      // Update old class name to PSR-0.
      if ($mailer_class == 'DefaultMailSystem') {
        $mailer_class = 'Drupal\Core\Mail\PhpMail';
      }
      // New default key.
      if ($key == 'default-system') {
        $new_mail_system_settings['default'] = $mailer_class;
        unset($old_mail_system_settings[$key]);
      }
    }
    if (count($old_mail_system_settings)) {
      // Warn about non-core classes which may need to be updated.
      drupal_set_message(format_string('The following mail backends need to be re-configured: @list.', array('@list' => implode(', ', $old_mail_system_settings))), 'warning');
    }

    $new_mail_system_settings += $old_mail_system_settings;
    // Save the updated variable, and let update_variables_to_config convert it.
    if ($new_mail_system_settings) {
      update_variable_set('mail_system', $new_mail_system_settings);
    }
  }
  update_variables_to_config('system.mail', array(
    'mail_system' => 'interface',
  ));
}

/**
 * Add route_name column to the menu_links table.
 */
function system_update_8051() {
  $spec = array(
    'description' => 'The machine name of a defined Symfony Route this menu item represents.',
    'type' => 'varchar',
    'length' => 255,
  );

  db_add_field('menu_links', 'route_name', $spec);
}

/**
 * Move image toolkit settings from variable to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8052() {
  update_variables_to_config('system.image', array(
    'image_toolkit' => 'toolkit',
  ));
  update_variables_to_config('system.image.gd', array(
    'image_jpeg_quality' => 'jpeg_quality',
  ));
}

/**
 * Remove {cache_form} table.
 */
function system_update_8053() {
  db_drop_table('cache_form');
}

/**
 * Add route_name column to the menu_router table.
 */
function system_update_8054() {
  $spec = array(
    'description' => 'The machine name of a defined Symfony Route this menu item represents.',
    'type' => 'varchar',
    'length' => 255,
  );

  db_add_field('menu_router', 'route_name', $spec);
}

/**
 * Move system theme settings from variables to config.
 */
function system_update_8055() {
  // Install the global theme settings from the system module.
  update_install_default_config('module', 'system.theme.global');
  // Add the global settings to a map for variable to configuration conversion.
  $theme_settings_to_config_map = array('theme_settings' => 'system.theme.global');

  // Can only upgrade core themes since if you follow the instructions in
  // UPGRADE.txt list_themes() would only return core themes at this point.
  // Therefore limit to a hard coded list to ensure that this update only
  // applies to core provided themes.
  $core_themes = array(
    'bartik',
    'seven',
    'stark',
  );

  // Add the core theme to the variable to configuration conversion map and
  // install the default configuration.
  foreach ($core_themes as $theme) {
    $variable = 'theme_' . $theme . '_settings';
    $config_name = $theme . '.settings';
    $theme_settings_to_config_map[$variable] = $config_name;
    update_install_default_config('theme', $config_name);
  }

  // Convert array of theme settings from Drupal 7's variable system to Drupal
  // 8's configuration management system.
  foreach ($theme_settings_to_config_map as $variable => $config_name) {
    $config = \Drupal::config($config_name);
    $theme_settings = update_variable_get($variable);
    if (!empty($theme_settings)) {
      theme_settings_convert_to_config($theme_settings, $config)->save();
    }
    update_variable_del($variable);
  }
}

/**
 * Move entity view modes to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8056() {
  // We cannot call entity_get_info() in an update hook, so we hardcode the view
  // modes. Only the node entity type's teaser view mode is set to custom by
  // default, we check specifically for that below. The only way to add custom
  // view modes in Drupal 7 was hook_entity_info_alter(), which still works in
  // Drupal 8.
  $entity_view_modes = array(
    'node' => array(
      'full' => 'Full content',
      'teaser' => 'Teaser',
      'rss' => 'RSS',
      'search_index' => 'Search index',
      'search_result' => 'Search result',
      'print' => 'Print',
    ),
    'comment' => array(
      'full' => 'Full comment',
    ),
    'user' => array(
      'full' => 'User account',
      'compact' => 'Compact',
    ),
    'taxonomy_term' => array(
      'full' => 'Taxonomy term page',
    ),
  );

  foreach ($entity_view_modes as $entity_type => $view_modes) {
    foreach ($view_modes as $key => $name) {
      $status = in_array($key, array('teaser', 'compact'));
      \Drupal::config("entity.view_mode.$entity_type.$key")
        ->set('id', "$entity_type.$key")
        ->set('label', $name)
        ->set('targetEntityType', $entity_type)
        ->set('status', $status)
        ->save();
    }
  }
}

/**
 * Convert actions to configuration.
 *
 * @ingroup config_upgrade
 */
function system_update_8057() {
  $actions = db_query("SELECT * FROM {actions}")->fetchAllAssoc('aid', PDO::FETCH_ASSOC);
  $action_plugins = \Drupal::service('plugin.manager.action')->getDefinitions();
  foreach ($actions as $action) {
    if (isset($action_plugins[$action['callback']])) {
      if (is_numeric($action['aid'])) {
        $action['aid'] = $action['callback'] . '_' . $action['aid'];
      }
      $configuration = unserialize($action['parameters']) ?: array();
      \Drupal::config('system.action.' . $action['aid'])
        ->set('id', $action['aid'])
        ->set('label', $action['label'])
        ->set('status', '1')
        ->set('type', $action['type'])
        ->set('plugin', $action['callback'])
        ->set('configuration', $configuration)
        ->save();
    }
  }
}

/**
 * Change the length of the 'module' column to the maximum length.
 *
 * @see system_update_8048()
 */
function system_update_8058() {
  if (db_field_exists('menu_links', 'module')) {
    $spec = array(
      'description' => 'The name of the module that generated this link.',
      'type' => 'varchar',
      'length' => 50,
      'not null' => TRUE,
      'default' => 'system',
    );
    db_change_field('menu_links', 'module', 'module', $spec);
  }
}

/**
 * Move variable language_types to config.
 *
 * @ingroup config_upgrade
 */
function system_update_8059() {
  update_variables_to_config('system.language.types', array(
    'language_interface' => 'configurable.language_interface',
    'language_content' => 'configurable.language_content',
    'language_url' => 'configurable.language_content',
  ));
}

/**
 * Move the file_public_path variable to settings.
 */
function system_upgrade_8060() {
  if ($path = update_variable_get('file_public_path')) {
    drupal_rewrite_settings(array('settings' => array('file_public_path' => $path)));
  }
}

/**
 * Add route_parameters column to the menu_links table.
 */
function system_update_8060() {
  $spec = array(
    'description' => 'Serialized array of route parameters of this menu link.',
    'type' => 'blob',
    'size' => 'big',
    'not null' => FALSE,
    'serialize' => TRUE,
  );

  db_add_field('menu_links', 'route_parameters', $spec);
}

/**
 * @} End of "defgroup updates-7.x-to-8.x".
 * The next series of updates should start at 9000.
 */
